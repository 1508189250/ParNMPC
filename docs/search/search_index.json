{
    "docs": [
        {
            "location": "/", 
            "text": "ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC\n\n\nIntroduction\n\n\nParNMPC\n is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC).\n\nParNMPC\n can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of \n\\mu\n\\mu\ns). \nThe purpose of \nParNMPC\n is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation and deployment.\n\n\nFeatures\n\n\n\n\nSymbolic problem representation\n\n\nAutomatic parallel C/C++ code generation with OpenMP\n\n\nFast rate of convergence (up to be superlinear)\n\n\nHighly parallelizable (capable of using at most N cores, N is the # of discretization steps)\n\n\nHigh speedup ratio\n\n\nMATLAB \n Simulink \n\n\n\n\nWhat Kind of Problems Supported in  \nParNMPC\n?\n\n\nThe optimization control problem (OCP) supported in \nParNMPC\n is defined as follows:\n\n\n\n\n\\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}\n\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad \nx(0) = \\bar{x}_0,\\\\\n\nM\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n\n C(u(t),x(t),p(t))=0,\\quad t\\in[0,T].\n\\end{align}\n\n\n\\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\\n&M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n& C(u(t),x(t),p(t))=0,\\quad t\\in[0,T].\n\\end{align}\n\n\n\n\nHere,\n\n\n\n\n\n\n\n\nSign\n\n\nSize\n\n\nDescription\n\n\nSign\n\n\nSize\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nu\nu\n\n\n[uDim,1]\n\n\nInput vector\n\n\nL\nL\n\n\n[1,1]\n\n\nCost function\n\n\n\n\n\n\nx\nx\n\n\n[xDim,1]\n\n\nState vector\n\n\nC\nC\n\n\n[muDim,1]\n\n\nEquality constraint function\n\n\n\n\n\n\np\np\n\n\n[pDim,1]\n\n\nGiven parameter vector\n\n\nf\nf\n\n\n[xDim,1]\n\n\nDynamics\n\n\n\n\n\n\nT\nT\n\n\n[1,1]\n\n\nPrediction horizon\n\n\nM\nM\n\n\n[xDim,1]\n\n\n(Optional, e.g., Lagrange model)\n\n\n\n\n\n\n\\bar{x}_0\n\\bar{x}_0\n\n\n[xDim,1]\n\n\nCurrent state vector\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nNMPC with inequality constraints can be transfered into equality constrained problems.\nFor detailed instructions, check \nTips \n Handling Inequality Constraints\n.\n\n\nVarying dynamics, prediction horizon and references, and terminal cost function can be achieved by utilizing the parameter \np\np\n.\n\n\n\n\n\n\nHow \nParNMPC\n Solves the OCP?\n\n\nDiscretization\n\n\nParNMPC\n  discretizes the OCP defined above into the following problem with \nN\nN\n steps:\n\n\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}\nL(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad \n x_0 = \\bar{x}_0,\\\\\n\nF(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\n\nHere, the continuous-time state equation \n\\dot{x}(t)=f(u(t),x(t),p(t))\n\\dot{x}(t)=f(u(t),x(t),p(t))\n (if \nM\nM\n is not imposed) is discretized to be \nF(x_{i-1},u_i,x_i,p_i)=0\nF(x_{i-1},u_i,x_i,p_i)=0\n, e.g., the backward Euler's method with \nF(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i\nF(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i\n, where \n\\Delta\\tau=T/N\n\\Delta\\tau=T/N\n.\n\n\nSolving the KKT conditions iteratively in parallel\n\n\nThen, \nParNMPC\n derives the KKT conditions for the discretized OCP by introducing Lagrange multipliers \n\\{\\lambda_i\\}_{i=1}^{N}\n\\{\\lambda_i\\}_{i=1}^{N}\n for the state equations and \n\\{\\mu_i\\}_{i=1}^{N}\n\\{\\mu_i\\}_{i=1}^{N}\n for the equality constraints.\n\n\nNext, \nParNMPC\n solves the KKT conditions iteratively in parallel for a given initial state \n\\bar{x}_0\n\\bar{x}_0\n and given parameters \n\\{p_i\\}_{i=1}^{N}\n\\{p_i\\}_{i=1}^{N}\n.\nThe NMPC controller is implemented by applying the first optimal control input \nu_1^*\nu_1^*\n as the actual input.\n\n\n\n\nNote\n\n\n\n\nThe iterative solver of \nParNMPC\n relies on warm start. \nParNMPC\n provides tools to solve the very first OCP offline.\n\n\nParNMPC\n provides tools to define the controlled plant model for simulation.", 
            "title": "What is ParNMPC"
        }, 
        {
            "location": "/#parnmpc-a-parallel-computing-toolbox-for-nonlinear-mpc", 
            "text": "", 
            "title": "ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC"
        }, 
        {
            "location": "/#introduction", 
            "text": "ParNMPC  is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). ParNMPC  can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of  \\mu \\mu s). \nThe purpose of  ParNMPC  is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation and deployment.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "Symbolic problem representation  Automatic parallel C/C++ code generation with OpenMP  Fast rate of convergence (up to be superlinear)  Highly parallelizable (capable of using at most N cores, N is the # of discretization steps)  High speedup ratio  MATLAB   Simulink", 
            "title": "Features"
        }, 
        {
            "location": "/#what-kind-of-problems-supported-in-parnmpc", 
            "text": "The optimization control problem (OCP) supported in  ParNMPC  is defined as follows:   \\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)} \\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad  x(0) = \\bar{x}_0,\\\\ M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\  C(u(t),x(t),p(t))=0,\\quad t\\in[0,T].\n\\end{align}  \\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\\n&M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n& C(u(t),x(t),p(t))=0,\\quad t\\in[0,T].\n\\end{align}   Here,     Sign  Size  Description  Sign  Size  Description      u u  [uDim,1]  Input vector  L L  [1,1]  Cost function    x x  [xDim,1]  State vector  C C  [muDim,1]  Equality constraint function    p p  [pDim,1]  Given parameter vector  f f  [xDim,1]  Dynamics    T T  [1,1]  Prediction horizon  M M  [xDim,1]  (Optional, e.g., Lagrange model)    \\bar{x}_0 \\bar{x}_0  [xDim,1]  Current state vector         Note   NMPC with inequality constraints can be transfered into equality constrained problems.\nFor detailed instructions, check  Tips   Handling Inequality Constraints .  Varying dynamics, prediction horizon and references, and terminal cost function can be achieved by utilizing the parameter  p p .", 
            "title": "What Kind of Problems Supported in  ParNMPC?"
        }, 
        {
            "location": "/#how-parnmpc-solves-the-ocp", 
            "text": "", 
            "title": "How ParNMPC Solves the OCP?"
        }, 
        {
            "location": "/#discretization", 
            "text": "ParNMPC   discretizes the OCP defined above into the following problem with  N N  steps:   \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad   x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\  C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}  \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}   Here, the continuous-time state equation  \\dot{x}(t)=f(u(t),x(t),p(t)) \\dot{x}(t)=f(u(t),x(t),p(t))  (if  M M  is not imposed) is discretized to be  F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 , e.g., the backward Euler's method with  F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i , where  \\Delta\\tau=T/N \\Delta\\tau=T/N .", 
            "title": "Discretization"
        }, 
        {
            "location": "/#solving-the-kkt-conditions-iteratively-in-parallel", 
            "text": "Then,  ParNMPC  derives the KKT conditions for the discretized OCP by introducing Lagrange multipliers  \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N}  for the state equations and  \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N}  for the equality constraints.  Next,  ParNMPC  solves the KKT conditions iteratively in parallel for a given initial state  \\bar{x}_0 \\bar{x}_0  and given parameters  \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} .\nThe NMPC controller is implemented by applying the first optimal control input  u_1^* u_1^*  as the actual input.   Note   The iterative solver of  ParNMPC  relies on warm start.  ParNMPC  provides tools to solve the very first OCP offline.  ParNMPC  provides tools to define the controlled plant model for simulation.", 
            "title": "Solving the KKT conditions iteratively in parallel"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\n\n\nClone or download \nParNMPC\n from \nGithub: ParNMPC\n.\n\n\n\n\nExtract the downloaded file.\n\n\n\n\nRequirements\n\n\nParNMPC\n supports MATLAB R2016a or later, and requires the following tools:\n\n\n\n\nMATLAB Coder\n\n\nMATLAB Optimization Toolbox\n\n\nMATLAB Parallel Computing Toolbox\n\n\nMATLAB Symbolic Math Toolbox\n\n\nC/C++ compiler supporting parallel code generation\n\n\n\n\nFor compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check \nSupported and Compatible Compilers\n for details.\n\n\n\n\n\n\nWarning\n\n\nParNMPC\n may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds.\nCheck \nsym bug report\n for details.\n\n\n\n\n\n\n\n\nDirectory Layout\n\n\nThe directory layout of \nParNMPC\n is as follows:\n\n\n.\n\u251c\u2500 ParNMPC/                  \n# Toolkit\n\n\u2502  \u251c\u2500 ...\n\u251c\u2500 docs/                     \n# Homepage\n\n\u2502  \u251c\u2500 ...                    \n\u251c\u2500 SemiActiveDamper/         \n# Example of controlling a semi-active damper\n\n\u2502  \u251c\u2500 NMPC_Problem_Formulation.m    \n# NMPC formulation and initialization                   \n\n\u2502  \u251c\u2500 Simu_Matlab.m                 \n# Closed-loop simulation in MATLAB                    \n\n\u2502  \u251c\u2500 Simu_Simulink.slx             \n# Closed-loop simulation in Simulink      \n\n\u2502  \u251c\u2500 Simu_Simulink_Setup.m         \n# Setup for the Simulink simulation              \n\n\u2502  \u251c\u2500 Timer.m                       \n# Your own timer function           \n\n\u2502  \u251c\u2500 GEN_initData.mat              \n# Initial guess                    \n\n\u251c\u2500 DoubleInvertedPendulum/   \n# Example of swinging up a double inverted pendulum on a cart\n\n\u2502  \u251c\u2500 ...                    \n\u2514\u2500 Quadrotor/                \n# Example of controlling a quadrotor\n\n\u2502  \u251c\u2500 ...                    \n\n\n\n\nGetting Started\n\n\nThis section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example.\n\n\n\n\n\n\nRun the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler:\n\n \nmex\n \n-\nsetup\n\n\n\n\n\n\n\n\nNavigate to the \nQuadrotor/\n folder.\n\n \ncd\n  \nQuadrotor\n/\n\n\n\n\n\n\n\n\nOpen \nNMPC_Problem_Formulation.m\n and run. By running this file, the following things are done:\n\n\n\n\nThe NMPC controller is defined and configured, and necessary files are automatically generated to the \n./funcgen/\n and \n./codegen/\n folders.\n\n\nThe very first OCP is solved and its solution is saved to \nGEN_initData.mat\n.\n\n\nThe controlled plant for simulation is defined and auto-generated.\n\n\n\n\n\n\n\n\nOpen \nSimu_Simulink_Setup.m\n and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file.\n\n\n\n\n\n\nOpen \nSimu_Simulink.slx\n and run. \nSimu_Simulink.slx\n calls the generated NMPC controller function from the DLL file.\n\n\n\n\nWarning\n\n\nRunning \nSimu_Matlab.m\n directly is not in parallel.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Clone or download  ParNMPC  from  Github: ParNMPC .   Extract the downloaded file.   Requirements  ParNMPC  supports MATLAB R2016a or later, and requires the following tools:   MATLAB Coder  MATLAB Optimization Toolbox  MATLAB Parallel Computing Toolbox  MATLAB Symbolic Math Toolbox  C/C++ compiler supporting parallel code generation   For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check  Supported and Compatible Compilers  for details.    Warning  ParNMPC  may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds.\nCheck  sym bug report  for details.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#directory-layout", 
            "text": "The directory layout of  ParNMPC  is as follows:  .\n\u251c\u2500 ParNMPC/                   # Toolkit \n\u2502  \u251c\u2500 ...\n\u251c\u2500 docs/                      # Homepage \n\u2502  \u251c\u2500 ...                    \n\u251c\u2500 SemiActiveDamper/          # Example of controlling a semi-active damper \n\u2502  \u251c\u2500 NMPC_Problem_Formulation.m     # NMPC formulation and initialization                    \n\u2502  \u251c\u2500 Simu_Matlab.m                  # Closed-loop simulation in MATLAB                     \n\u2502  \u251c\u2500 Simu_Simulink.slx              # Closed-loop simulation in Simulink       \n\u2502  \u251c\u2500 Simu_Simulink_Setup.m          # Setup for the Simulink simulation               \n\u2502  \u251c\u2500 Timer.m                        # Your own timer function            \n\u2502  \u251c\u2500 GEN_initData.mat               # Initial guess                     \n\u251c\u2500 DoubleInvertedPendulum/    # Example of swinging up a double inverted pendulum on a cart \n\u2502  \u251c\u2500 ...                    \n\u2514\u2500 Quadrotor/                 # Example of controlling a quadrotor \n\u2502  \u251c\u2500 ...", 
            "title": "Directory Layout"
        }, 
        {
            "location": "/installation/#getting-started", 
            "text": "This section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example.    Run the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler:   mex   - setup     Navigate to the  Quadrotor/  folder.   cd    Quadrotor /     Open  NMPC_Problem_Formulation.m  and run. By running this file, the following things are done:   The NMPC controller is defined and configured, and necessary files are automatically generated to the  ./funcgen/  and  ./codegen/  folders.  The very first OCP is solved and its solution is saved to  GEN_initData.mat .  The controlled plant for simulation is defined and auto-generated.     Open  Simu_Simulink_Setup.m  and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file.    Open  Simu_Simulink.slx  and run.  Simu_Simulink.slx  calls the generated NMPC controller function from the DLL file.   Warning  Running  Simu_Matlab.m  directly is not in parallel.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/interfaces/", 
            "text": "Interfaces\n\n\nClasses\n\n\n\n\n\n\n\n\nClass name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nFormulate an OCP\n\n\n\n\n\n\nNMPCSolver\n\n\nConfigurate the NMPC solver\n\n\n\n\n\n\nOCPSolver\n\n\nSolve the very first OCP offline\n\n\n\n\n\n\nDynamicSystem\n\n\nConstruct a dynamic system\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nFormulate an OCP.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndim\n\n\nstructure.{lambda,mu,u;x;p}\n, dimensions of lambda, mu, u, x, p.\n\n\n\n\n\n\nlambda\n\n\nsymbolic vector [xDim,1]\n, multiplier vector.\n\n\n\n\n\n\nmu\n\n\nsymbolic vector [muDim,1]\n, multiplier vector.\n\n\n\n\n\n\nu\n\n\nsymbolic vector [uDim,1]\n, input vector.\n\n\n\n\n\n\nx\n\n\nsymbolic vector [xDim,1]\n, state vector.\n\n\n\n\n\n\np\n\n\nsymbolic vector [pDim,1]\n, parameter vector.\n\n\n\n\n\n\nf\n\n\nsymbolic expression [xDim,1]\n, function f.\n\n\n\n\n\n\nM\n\n\nsymbolic expression [xDim,xDim]\n, matrix M .\n\n\n\n\n\n\nL\n\n\nsymbolic expression [1,1]\n, function L.\n\n\n\n\n\n\nC\n\n\nsymbolic expression [muDim,1]\n, function C.\n\n\n\n\n\n\nN\n\n\npositive integer [1,1]\n, number of discretization grids N.\n\n\n\n\n\n\nT\n\n\npositive [1,1]\n, prediction horizon T.\n\n\n\n\n\n\ndeltaTau\n\n\npositive [1,1]\n, discretization size (T/N).\n\n\n\n\n\n\ndiscretizationMethod\n\n\nstring\n, discretization method.\n\n\n\n\n\n\nisMEnabled\n\n\nbool\n, whether the M matrix is enabled.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nConstructor.\nInput:\nmuDim\n: \nnonnegtive integer [1,1]\n, dimension of mu.\nuDim\n: \npositive integer [1,1]\n, dimension of u.\nxDim\n: \npositive integer [1,1]\n, dimension of x.\npDim\n: \nnonnegtive integer [1,1]\n, dimension of p.\nT\n: \npositive [1,1]\n, prediction horizon.\nN\n: \npositive integer [1,1]\n, number of discretization grids.\nOutput:\nOptimalControlProblem\n\n\n\n\n\n\nsetf\n\n\nSet f.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetM\n\n\nSet M.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetStateName\n\n\nGive names to all or part of the states.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetInputName\n\n\nGive names to all or part of the inputs.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetParameterName\n\n\nGive names to all or part of the parameters.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetL\n\n\nSet L.\nInput:\nL\n: \nsymbolic expression [1,1]\n, function L.\nOutput: none.\n\n\n\n\n\n\nsetC\n\n\nSet C.\nInput:\nC\n: \nsymbolic expression [muDim,1]\n, function C.\nOutput: none.\n\n\n\n\n\n\nsetT\n\n\nSet T.\nInput:\nT\n: \nsymbolic variable/double [1,1]\n, must be included in \np\n if it is a symbolic variable.\nOutput: none.\n\n\n\n\n\n\nsetDiscretizationMethod\n\n\nSet the discretization method.\nInput:\nmethod\n: \nstring\n, \nEuler\n or \nRK4\n, discretization method.\nOutput: none\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nNMPCSolver\n\n\nConfigurate the NMPC solver.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCP\n\n\nOptimalControlProblem\n, OptimalControlProblem object.\n\n\n\n\n\n\nHessianApproximation\n\n\nstring\n, Hessian approximation method.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNMPCSolver\n\n\nConstructor.\nInput:\nOCP\n: \nOptimalControlProblem\n, OptimalControlProblem object.\nOutput:\nNMPCSolver\n\n\n\n\n\n\nsetHessianApproximation\n\n\nSet the Hessian approximation method.\nInput:\nmethod\n: \nstring\n, \nNewton\n or \nGaussNewton\n, method of Hessian approximation.\nOutput: none\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nOCPSolver\n\n\nSolve the very first OCP offline.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCP\n\n\nOptimalControlProblem\n, OptimalControlProblem object.\n\n\n\n\n\n\nNMPCSolver\n\n\nNMPCSolver\n, NMPCSolver object.\n\n\n\n\n\n\nx0\n\n\n[xDim,1]\n, initial state.\n\n\n\n\n\n\nlambda\n\n\n[xDim,N]\n, multipliers.\n\n\n\n\n\n\nmu\n\n\n[muDim,N]\n, multipliers.\n\n\n\n\n\n\nu\n\n\n[uDim,N]\n, inputs.\n\n\n\n\n\n\nx\n\n\n[xDim,N]\n, states.\n\n\n\n\n\n\np\n\n\n[pDim,N]\n, given parameters.\n\n\n\n\n\n\nLAMBDA\n\n\n[xDim,xDim,N]\n, dependent variable LAMBDA.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCPSolver\n\n\nConstructor.\nInput:\nOCP\n: \nOptimalControlProblem\n, OptimalControlProblem object.\nNMPCSolver\n: \nNMPCSolver\n, NMPCSolver object.\nx0\n: \n[xDim,1]\n, initial state.\npar\n: \n[pDim,N]\n, given parameters.\nOutput:\nOCPSolver\n\n\n\n\n\n\nOCPSolve\n\n\nSolve the OCP with a providing initial guess offline.\nInput:\nlambdaInitGuess\n: \n[xDim,N]\n, initial guess of lambda.\nmuInitGuess\n: \n[muDim,N]\n, initial guess of mu.\nuInitGuess\n: \n[uDim,N]\n, initial guess of u.\nxInitGuess\n: \n[xDim,N]\n, initial guess of x.\nmethod\n: \nstring\n, \nfsolve\n or \nNMPC_Iter_GaussNewton\n, solver.\nOutput: \nlambda\n: \n[xDim,N]\n, optimal value of lambda.\nmu\n: \n[muDim,N]\n, optimal value of mu.\nu\n: \n[uDim,N]\n, optimal value of u.\nx\n: \n[xDim,N]\n, optimal value of x.\n\n\n\n\n\n\ninitFromMatFile\n\n\nInitialize from file with automatic interpolation.\nInput:\nmatFile\n: \nstring\n, file name of the mat file.\nOutput: \nlambda\n: \n[xDim,N]\n, interpolated value of lambda.\nmu\n: \n[muDim,N]\n, interpolated value of mu.\nu\n: \n[uDim,N]\n, interpolated value of u.\nx\n: \n[xDim,N]\n, interpolated value of x.\n\n\n\n\n\n\ninitFromStartEnd\n\n\nInitialize from the start and the end values by linear interpolation.\nInput:\nlambdaStart\n: \n[xDim,1]\n, start value of lambda.\nmuStart\n: \n[muDim,1]\n, start value of mu.\nuStart\n: \n[uDim,1]\n, start value of u.\nxStart\n: \n[xDim,1]\n, start value of x.\nlambdaEnd\n: \n[xDim,1]\n, end value of lambda.\nmuEnd\n: \n[muDim,1]\n, end value of mu.\nuEnd\n: \n[uDim,1]\n, end value of u.\nxEnd\n: \n[xDim,1]\n, end value of x.\nmethod\n: \nstring\n, \nfsolve\n or \nNMPC_Iter_GaussNewton\n, solver.\nOutput: \nlambda\n: \n[xDim,N]\n, interpolated value of lambda.\nmu\n: \n[muDim,N]\n, interpolated value of mu.\nu\n: \n[uDim,N]\n, interpolated value of u.\nx\n: \n[xDim,N]\n, interpolated value of x.\n\n\n\n\n\n\ngetLAMBDA\n\n\nGet the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p.\nInput:\nx0\n: \n[xDim,1]\n, initial state.\nlambda\n: \n[xDim,N]\n, lambda.\nmu\n: \n[muDim,N]\n, mu.\nu\n: \n[uDim,N]\n, u.\nx\n: \n[xDim,N]\n, x.\np\n: \n[pDim,N]\n, p.\nOutput:\nLAMBDA\n: \n[xDim,xDim,N]\n\n\n\n\n\n\ngetCost\n\n\nGet the cost function from the given u, x, p.\nInput:\nu\n: \n[uDim,N]\n, u.\nx\n: \n[xDim,N]\n, x.\np\n: \n[pDim,N]\n, p.\nOutput:\ncost\n: \n[1,1]\n\n\n\n\n\n\n\n\nDynamicSystem\n\n\nConstruct a dynamic system \nM(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t))\nM(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t))\n.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndim\n\n\nstructure.{u;x;p}\n, dimensions of u, x, p.\n\n\n\n\n\n\nu\n\n\nsymbolic vector [uDim,1]\n, input vector.\n\n\n\n\n\n\nx\n\n\nsymbolic vector [xDim,1]\n, state vector.\n\n\n\n\n\n\np\n\n\nsymbolic vector [pDim,1]\n, parameter vector.\n\n\n\n\n\n\nf\n\n\nsymbolic expression [xDim,1]\n, function f.\n\n\n\n\n\n\nM\n\n\nsymbolic expression [xDim,xDim]\n, matrix M .\n\n\n\n\n\n\nisMEnabled\n\n\nbool\n, whether the M matrix is enabled.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDynamicSystem\n\n\nConstructor.\nInput:\nuDim\n: \n[1,1]\n, dimension of u.\nxDim\n: \n[1,1]\n, dimension of x.\npDim\n: \n[1,1]\n, dimension of p.\nOutput:\nDynamicSystem\n\n\n\n\n\n\nsetf\n\n\nSet f.\nInput:\nf\n: \nsymbolic expression [xDim,1]\n, function f.\nOutput: none.\n\n\n\n\n\n\nsetM\n\n\nSet M.\nInput:\nM\n: \nsymbolic expression [xDim,xDim]\n, M matrix.\nOutput: none.\n\n\n\n\n\n\nsetStateName\n\n\nGive names to all or part of the states.\nExample:\n[X,Y,Z] =~.setStateName({\nX\n,\nY\n,\nZ\n});\n[X,Z] =~.setStateName({\nX\n,\nZ\n},[1 3]);\n\n\n\n\n\n\nsetInputName\n\n\nGive names to all or part of the inputs.\nExample:\n[F1,F2,F3] =~.setInputName({\nF1\n,\nF2\n,\nF3\n};\n[F1,F3] =~.setInputName({\nF1\n,\nF3\n},[1 3]);\n\n\n\n\n\n\nsetParameterName\n\n\nGive names to all or part of the parameters.\nExample:\n[a,b,c] =~.setParameterName({\na\n,\nb\n,\nc\n};\n[a,c] =~.setParameterName({\na\n,\nc\n},[1 3]);\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nFunctions\n\n\n\n\n\n\n\n\nFunction name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNMPC_Iter\n\n\nPerform one iteration  for solving the KKT conditions.\n\n\n\n\n\n\nNMPC_Iter_CodeGen\n\n\nGenerate code for function \nNMPC_Iter\n.\n\n\n\n\n\n\nSIM_Plant_RK4\n\n\nSimulate the dynamic system using the 4-order Runge-Kutta method.\n\n\n\n\n\n\nTimer\n\n\nSpecify your own timer function.\n\n\n\n\n\n\n\n\nNMPC_Iter\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nNMPC_Iter\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nPerform one iteration to solve the KKT conditions.\n\n\n\n\n\n\nInput\n\n\nx0\n: \n[xDim,1]\n, initial state.\nlambda\n: \n[xDim,N/DoP,DoP]\n, initial guess of lambda.\nmu\n: \n[muDim,N/DoP,DoP]\n, initial guess of mu.\nu\n: \n[uDim,N/DoP,DoP]\n, initial guess of u.\nx\n: \n[xDim,N/DoP,DoP]\n, initial guess of x.\np\n: \n[pDim,N/DoP,DoP]\n, given parameters.\nLAMBDA\n: \n[xDim,xDim,N/DoP,DoP]\n, initial guess of LAMBDA.\ndiscretizationMethod\n: \nstring\n, must be consistent with the discretization method set in \nOptimalControlProblem\n.\nisMEnabled\n: \nbool\n, must be consistent with the value in \nOptimalControlProblem\n.\n\n\n\n\n\n\nOutput\n\n\nlambda\n: \n[xDim,N/DoP,DoP]\n.\nmu\n: \n[muDim,N/DoP,DoP]\n.\nu\n: \n[uDim,N/DoP,DoP]\n.\nx\n: \n[xDim,N/DoP,DoP]\n.\nLAMBDA\n: \n[xDim,xDim,N/DoP,DoP]\n.\ncost\n: \n[1,1]\n, evaluation of the cost function after iteration.\nerror\n: \n[1,1]\n, Euclidean norm of the KKT conditions.\ntimeElapsed\n: \n[1,1]\n, computation time in second.\n\n\n\n\n\n\n\n\nNMPC_Iter_CodeGen\n\n\n\n\nExample\n\n\n./Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nNMPC_Iter_CodeGen\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nGenerate code for function \nNMPC_Iter\n.\n\n\n\n\n\n\nInput\n\n\ntarget\n: \nstring\n, \nmex\n, \ndll\n, or \nmex\n, target.\ntargetLang\n: \nstring\n, \nC\n or '\nC++\n', target language.\nargs\n: \ncell\n, arguments applied to \nNMPC_Iter\n.\n\n\n\n\n\n\nOutput\n\n\nNone\n\n\n\n\n\n\n\n\nSIM_Plant_RK4\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nSIM_Plant_RK4\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSimulate the dynamic system using the 4-order Runge-Kutta method.\n\n\n\n\n\n\nInput\n\n\nu\n: \n[uDim,1]\n, inputs applied to the plant.\nx\n: \n[xDim,1]\n, current state of the plant.\np\n: \n[pDim,1]\n, given parameters.\nTs\n: \npositive [1,1]\n, sampling interval.\n\n\n\n\n\n\nOutput\n\n\nxNext\n: \n[xDim,1]\n, next state of the plant.\n\n\n\n\n\n\n\n\nTimer\n\n\n\n\nExample\n\n\n./Timer.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nTimer\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nMeasure the current time.\n\n\n\n\n\n\nInput\n\n\nNone\n\n\n\n\n\n\nOutput\n\n\nt\n: \n[1,1]\n, current time.\n\n\n\n\n\n\nStatement\n\n\nCreate \nTimer.m\n in the working directory to specify your own timer function.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/interfaces/#interfaces", 
            "text": "", 
            "title": "Interfaces"
        }, 
        {
            "location": "/interfaces/#classes", 
            "text": "Class name  Description      OptimalControlProblem  Formulate an OCP    NMPCSolver  Configurate the NMPC solver    OCPSolver  Solve the very first OCP offline    DynamicSystem  Construct a dynamic system", 
            "title": "Classes"
        }, 
        {
            "location": "/interfaces/#optimalcontrolproblem", 
            "text": "Formulate an OCP.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      dim  structure.{lambda,mu,u;x;p} , dimensions of lambda, mu, u, x, p.    lambda  symbolic vector [xDim,1] , multiplier vector.    mu  symbolic vector [muDim,1] , multiplier vector.    u  symbolic vector [uDim,1] , input vector.    x  symbolic vector [xDim,1] , state vector.    p  symbolic vector [pDim,1] , parameter vector.    f  symbolic expression [xDim,1] , function f.    M  symbolic expression [xDim,xDim] , matrix M .    L  symbolic expression [1,1] , function L.    C  symbolic expression [muDim,1] , function C.    N  positive integer [1,1] , number of discretization grids N.    T  positive [1,1] , prediction horizon T.    deltaTau  positive [1,1] , discretization size (T/N).    discretizationMethod  string , discretization method.    isMEnabled  bool , whether the M matrix is enabled.        Functions  Description      OptimalControlProblem  Constructor. Input: muDim :  nonnegtive integer [1,1] , dimension of mu. uDim :  positive integer [1,1] , dimension of u. xDim :  positive integer [1,1] , dimension of x. pDim :  nonnegtive integer [1,1] , dimension of p. T :  positive [1,1] , prediction horizon. N :  positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem    setf  Set f. Inherit from  DynamicSystem    setM  Set M. Inherit from  DynamicSystem    setStateName  Give names to all or part of the states. Inherit from  DynamicSystem    setInputName  Give names to all or part of the inputs. Inherit from  DynamicSystem    setParameterName  Give names to all or part of the parameters. Inherit from  DynamicSystem    setL  Set L. Input: L :  symbolic expression [1,1] , function L. Output: none.    setC  Set C. Input: C :  symbolic expression [muDim,1] , function C. Output: none.    setT  Set T. Input: T :  symbolic variable/double [1,1] , must be included in  p  if it is a symbolic variable. Output: none.    setDiscretizationMethod  Set the discretization method. Input: method :  string ,  Euler  or  RK4 , discretization method. Output: none    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "OptimalControlProblem"
        }, 
        {
            "location": "/interfaces/#nmpcsolver", 
            "text": "Configurate the NMPC solver.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      OCP  OptimalControlProblem , OptimalControlProblem object.    HessianApproximation  string , Hessian approximation method.        Functions  Description      NMPCSolver  Constructor. Input: OCP :  OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver    setHessianApproximation  Set the Hessian approximation method. Input: method :  string ,  Newton  or  GaussNewton , method of Hessian approximation. Output: none    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "NMPCSolver"
        }, 
        {
            "location": "/interfaces/#ocpsolver", 
            "text": "Solve the very first OCP offline.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      OCP  OptimalControlProblem , OptimalControlProblem object.    NMPCSolver  NMPCSolver , NMPCSolver object.    x0  [xDim,1] , initial state.    lambda  [xDim,N] , multipliers.    mu  [muDim,N] , multipliers.    u  [uDim,N] , inputs.    x  [xDim,N] , states.    p  [pDim,N] , given parameters.    LAMBDA  [xDim,xDim,N] , dependent variable LAMBDA.        Functions  Description      OCPSolver  Constructor. Input: OCP :  OptimalControlProblem , OptimalControlProblem object. NMPCSolver :  NMPCSolver , NMPCSolver object. x0 :  [xDim,1] , initial state. par :  [pDim,N] , given parameters. Output: OCPSolver    OCPSolve  Solve the OCP with a providing initial guess offline. Input: lambdaInitGuess :  [xDim,N] , initial guess of lambda. muInitGuess :  [muDim,N] , initial guess of mu. uInitGuess :  [uDim,N] , initial guess of u. xInitGuess :  [xDim,N] , initial guess of x. method :  string ,  fsolve  or  NMPC_Iter_GaussNewton , solver. Output:  lambda :  [xDim,N] , optimal value of lambda. mu :  [muDim,N] , optimal value of mu. u :  [uDim,N] , optimal value of u. x :  [xDim,N] , optimal value of x.    initFromMatFile  Initialize from file with automatic interpolation. Input: matFile :  string , file name of the mat file. Output:  lambda :  [xDim,N] , interpolated value of lambda. mu :  [muDim,N] , interpolated value of mu. u :  [uDim,N] , interpolated value of u. x :  [xDim,N] , interpolated value of x.    initFromStartEnd  Initialize from the start and the end values by linear interpolation. Input: lambdaStart :  [xDim,1] , start value of lambda. muStart :  [muDim,1] , start value of mu. uStart :  [uDim,1] , start value of u. xStart :  [xDim,1] , start value of x. lambdaEnd :  [xDim,1] , end value of lambda. muEnd :  [muDim,1] , end value of mu. uEnd :  [uDim,1] , end value of u. xEnd :  [xDim,1] , end value of x. method :  string ,  fsolve  or  NMPC_Iter_GaussNewton , solver. Output:  lambda :  [xDim,N] , interpolated value of lambda. mu :  [muDim,N] , interpolated value of mu. u :  [uDim,N] , interpolated value of u. x :  [xDim,N] , interpolated value of x.    getLAMBDA  Get the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p. Input: x0 :  [xDim,1] , initial state. lambda :  [xDim,N] , lambda. mu :  [muDim,N] , mu. u :  [uDim,N] , u. x :  [xDim,N] , x. p :  [pDim,N] , p. Output: LAMBDA :  [xDim,xDim,N]    getCost  Get the cost function from the given u, x, p. Input: u :  [uDim,N] , u. x :  [xDim,N] , x. p :  [pDim,N] , p. Output: cost :  [1,1]", 
            "title": "OCPSolver"
        }, 
        {
            "location": "/interfaces/#dynamicsystem", 
            "text": "Construct a dynamic system  M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) .   Example  ./NMPC_Problem_Formulation.m      Properties  Description      dim  structure.{u;x;p} , dimensions of u, x, p.    u  symbolic vector [uDim,1] , input vector.    x  symbolic vector [xDim,1] , state vector.    p  symbolic vector [pDim,1] , parameter vector.    f  symbolic expression [xDim,1] , function f.    M  symbolic expression [xDim,xDim] , matrix M .    isMEnabled  bool , whether the M matrix is enabled.        Functions  Description      DynamicSystem  Constructor. Input: uDim :  [1,1] , dimension of u. xDim :  [1,1] , dimension of x. pDim :  [1,1] , dimension of p. Output: DynamicSystem    setf  Set f. Input: f :  symbolic expression [xDim,1] , function f. Output: none.    setM  Set M. Input: M :  symbolic expression [xDim,xDim] , M matrix. Output: none.    setStateName  Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({ X , Y , Z }); [X,Z] =~.setStateName({ X , Z },[1 3]);    setInputName  Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({ F1 , F2 , F3 }; [F1,F3] =~.setInputName({ F1 , F3 },[1 3]);    setParameterName  Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({ a , b , c }; [a,c] =~.setParameterName({ a , c },[1 3]);    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "DynamicSystem"
        }, 
        {
            "location": "/interfaces/#functions", 
            "text": "Function name  Description      NMPC_Iter  Perform one iteration  for solving the KKT conditions.    NMPC_Iter_CodeGen  Generate code for function  NMPC_Iter .    SIM_Plant_RK4  Simulate the dynamic system using the 4-order Runge-Kutta method.    Timer  Specify your own timer function.", 
            "title": "Functions"
        }, 
        {
            "location": "/interfaces/#nmpc_iter", 
            "text": "Example  ./Simu_Matlab.m      Function name  NMPC_Iter      Description  Perform one iteration to solve the KKT conditions.    Input  x0 :  [xDim,1] , initial state. lambda :  [xDim,N/DoP,DoP] , initial guess of lambda. mu :  [muDim,N/DoP,DoP] , initial guess of mu. u :  [uDim,N/DoP,DoP] , initial guess of u. x :  [xDim,N/DoP,DoP] , initial guess of x. p :  [pDim,N/DoP,DoP] , given parameters. LAMBDA :  [xDim,xDim,N/DoP,DoP] , initial guess of LAMBDA. discretizationMethod :  string , must be consistent with the discretization method set in  OptimalControlProblem . isMEnabled :  bool , must be consistent with the value in  OptimalControlProblem .    Output  lambda :  [xDim,N/DoP,DoP] . mu :  [muDim,N/DoP,DoP] . u :  [uDim,N/DoP,DoP] . x :  [xDim,N/DoP,DoP] . LAMBDA :  [xDim,xDim,N/DoP,DoP] . cost :  [1,1] , evaluation of the cost function after iteration. error :  [1,1] , Euclidean norm of the KKT conditions. timeElapsed :  [1,1] , computation time in second.", 
            "title": "NMPC_Iter"
        }, 
        {
            "location": "/interfaces/#nmpc_iter_codegen", 
            "text": "Example  ./Simu_Simulink_Setup.m      Function name  NMPC_Iter_CodeGen      Description  Generate code for function  NMPC_Iter .    Input  target :  string ,  mex ,  dll , or  mex , target. targetLang :  string ,  C  or ' C++ ', target language. args :  cell , arguments applied to  NMPC_Iter .    Output  None", 
            "title": "NMPC_Iter_CodeGen"
        }, 
        {
            "location": "/interfaces/#sim_plant_rk4", 
            "text": "Example  ./Simu_Matlab.m      Function name  SIM_Plant_RK4      Description  Simulate the dynamic system using the 4-order Runge-Kutta method.    Input  u :  [uDim,1] , inputs applied to the plant. x :  [xDim,1] , current state of the plant. p :  [pDim,1] , given parameters. Ts :  positive [1,1] , sampling interval.    Output  xNext :  [xDim,1] , next state of the plant.", 
            "title": "SIM_Plant_RK4"
        }, 
        {
            "location": "/interfaces/#timer", 
            "text": "Example  ./Timer.m      Function name  Timer      Description  Measure the current time.    Input  None    Output  t :  [1,1] , current time.    Statement  Create  Timer.m  in the working directory to specify your own timer function.", 
            "title": "Timer"
        }, 
        {
            "location": "/workflow/", 
            "text": "Workflow of ParNMPC\n\n\nPreparation\n\n\n\n\nChoose a compiler that supports parallel code generation by \nmex -setup\n.\n\n\nEdit \nTimer.m\n to specify the timer function that measures the current time for your own platform.\n\n\n\n\nNMPC Problem Formulation \n\n\n\n\nExample\n\n\n./NMPC_Problem_Definition.m\n\n\n\n\n\n\n\n\nFormulate an OCP using Class \nOptimalControlProblem\n\n\n% Create an OptimalControlProblem object\n\n\nOCP\n \n=\n \nOptimalControlProblem\n(\nmuDim\n,\n... % constraints dim\n\n                            \nuDim\n,\n...  % inputs dim\n\n                            \nxDim\n,\n...  % states dim\n\n                            \npDim\n,\n...  % parameters dim (position reference)\n\n                            \nT\n,\n...     % prediction horizon\n\n                            \nN\n);\n       \n% num of discritization grids\n\n\n\n% Give names to x, u, p (optional)                          \n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetStateName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetInputName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetParameterName\n(\n~\n);\n\n\n\n% Reset the prediction horizon T \n\n\n% (optional for variable horizon or nonuniform discretization)\n\n\nOCP\n.\nsetT\n(\n~\n);\n\n\n\n% Set the dynamic function f\n\n\nOCP\n.\nsetf\n(\n~\n);\n\n\n\n% Set the matrix M (optional for, e.g., Lagrange model)\n\n\nOCP\n.\nsetM\n(\n~\n);\n\n\n\n% Set the equality constraint function C (optional)\n\n\nOCP\n.\nsetC\n(\n~\n);\n\n\n\n% Set the cost function L\n\n\nOCP\n.\nsetL\n(\n~\n);\n\n\n\n% Generate necessary files\n\n\nOCP\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nConfigrate the solver using Class \nNMPCSolver\n\n\n% Create a NMPCSolver object\n\n\nnmpcSolver\n \n=\n \nNMPCSolver\n(\nOCP\n);\n\n\n\n% Configurate the Hessian approximation method\n\n\nnmpcSolver\n.\nsetHessianApproximation\n(\n~\n);\n\n\n\n% Generate necessary files\n\n\nnmpcSolver\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nSolve the very first OCP for a given initial state and given parameters using Class \nOCPSolver\n\n\n% Set the initial state     \n\n\nx0\n \n=\n \n[\n~\n];\n\n\n\n% Set the parameters        \n\n\npar\n \n=\n \n[\n~\n];\n\n\n\n% Create an OCPSolver object\n\n\nocpSolver\n \n=\n \nOCPSolver\n(\nOCP\n,\nnmpcSolver\n,\nx0\n,\npar\n);\n\n\n\n% Choose one of the following methods to provide an initial guess:\n\n\n% 1. init guess by input\n\n\nlambdaInitGuess\n \n=\n \n[\n~\n];\n\n\nmuInitGuess\n     \n=\n \n[\n~\n];\n\n\nuInitGuess\n      \n=\n \n[\n~\n];\n\n\nxInitGuess\n      \n=\n \n[\n~\n];\n\n\n% 2. init guess by interpolation\n\n\n[\nlambdaInitGuess\n,\nmuInitGuess\n,\nuInitGuess\n,\nxInitGuess\n]\n \n=\n \n...\n\n    \nocpSolver\n.\ninitFromStartEnd\n(\n~\n);\n\n\n% 3. init guess from file\n\n\n[\nlambdaInitGuess\n,\nmuInitGuess\n,\nuInitGuess\n,\nxInitGuess\n]\n \n=\n \n...\n\n                        \nocpSolver\n.\ninitFromMatFile\n(\n~\n);\n\n\n\n% Solve the OCP                     \n\n\n[\nlambda\n,\nmu\n,\nu\n,\nx\n]\n \n=\n \nocpSolver\n.\nOCPSolve\n(\nlambdaInitGuess\n,\n...\n\n                                     \nmuInitGuess\n,\n...\n\n                                     \nuInitGuess\n,\n...\n\n                                     \nxInitGuess\n,\n...\n\n                                     \nmethod\n);\n\n\n\n% Get the dependent variable LAMBDA\n\n\nLAMBDA\n \n=\n \nocpSolver\n.\ngetLAMBDA\n(\nx0\n,\nlambda\n,\nmu\n,\nu\n,\nx\n,\npar\n);\n\n\n\n% Check the cost % (optional)\n\n\ncost\n \n=\n \nocpSolver\n.\ngetCost\n(\nu\n,\nx\n,\npar\n);\n \n\n\n% Save to file for further use\n\n\nsave\n \nGEN_initData\n.\nmat\n  \n...\n\n     \nx0\n \nlambda\n \nmu\n \nu\n \nx\n \npar\n \nLAMBDA\n \n~\n\n\n\n\n\n\n\n\nDefine the controlled plant using Class \nDynamicSystem\n (optional for simulation)\n\n% Create a DynamicSystem object\n\n\nplant\n \n=\n \nDynamicSystem\n(\nuDim\n,\nxDim\n,\npDim\n);\n\n\n\n% Give names to x, u, p (optional)\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetStateName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetInputName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetParameterName\n(\n~\n);\n\n\n\n% Set the dynamic function f\n\n\nplant\n.\nsetf\n(\n~\n);\n\n\n\n% Set the matrix M (optional for, e.g., Lagrange model)\n\n\nplant\n.\nsetM\n(\n~\n);\n\n\n\n% Generate necessary files\n\n\nplant\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nConfiguration Table:\n\n\n\n\n\n\n\n\nSituation\n\n\nConfigurable discretization method\n\n\nConfigurable Hessian approximation method\n\n\n\n\n\n\n\n\n\n\nM\n enabled\n\n\nEuler\n\n\nGaussNewton\n\n\n\n\n\n\nM\n disabled\n\n\nEuler\n, \nRK4\n\n\nNewton\n, \nGaussNewton\n when \nEuler\n;\nGaussNewton\n when \nRK4\n;\n\n\n\n\n\n\n\n\nCode Generation and Deployment\n\n\nMATLAB\n\n\nAssume that you have written a MATLAB function to carry out the closed-loop simulation for your problem defined above using the functions provided by ParNMPC, that is, \nNMPC_Iter\n is used to calculate the optimal control input, and \nSIM_Plant_RK4\n is used to simulate the controlled plant.\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\nCode generation\n\n\nAssume that you have run \nNMPC_Problem_Formulation.m\n.\nNext, the code generation process using the MATLAB Coder App for this simulation is shown. \n\n\n\n\n\n\nOpen the MATLAB Coder App.\n\n\n\n\n\n\nSelect \nSimu_Matlab.m\n.\n\n\n\n\n\n\nClick the \nGenerate\n button, and the C code will be automatically generated to \n./codegen/lib/Simu_Matlab\n.\n\n\n\n\n\n\nDeployment in Visual Studio\n\n\n\n\n\n\nCreate an empty Win32 Console Application project.\n\n\n\n\n\n\nChange to Release x64 mode.\n\n\n\n\n\n\nAdd  \n*.h\n and \n*.c\n files in \n.\\codegen\\lib\\Simu_Matlab\n to the project.\n\n\n\n\n\n\nAdd  \nmain.h\n and \nmain.c\n in \n.\\codegen\\lib\\Simu_Matlab\\examples\n to the project.\n\n\n\n\n\n\nAdd  \nOCP_F_Fu_Fx.h\n and \nOCP_F_Fu_Fx.c\n in \n.\\codegen\\lib\\OCP_F_Fu_Fx\n to the project.\n\n\n\n\n\n\nAdd directories \n.\\codegen\\lib\\Simu_Matlab\n and \n.\\codegen\\lib\\OCP_F_Fu_Fx\n to \nProperties \n C/C++ \n General \n  Additional Include Directories\n.\n\n\n\n\n\n\nProperties \n C/C++ \n Language \n  Open MP Support: Yes (/openmp)\n.\n\n\n\n\n\n\nCompile and run.\n\n\n\n\n\n\nSimulink \n\n\nWhen doing the closed-loop simulation in Simulink, you can call the generated C/C++ solver function \nNMPC_Iter\n directly to compute the optimal input.\n\n\nCode generation\n\n\n\n\nExample\n\n\n./Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDefine the degree of parallelism:\n\nDoP\n \n=\n \n~\n;\n \n% degree of parallism: 1 = in serial, otherwise in parallel\n\n\n\n\n\n\n\n\nSplit \n\\{\\lambda_i\\}_{i=1}^{N}\n\\{\\lambda_i\\}_{i=1}^{N}\n, \n\\{\\mu_i\\}_{i=1}^{N}\n\\{\\mu_i\\}_{i=1}^{N}\n, \n\\{u_i\\}_{i=1}^{N}\n\\{u_i\\}_{i=1}^{N}\n, \n\\{x_i\\}_{i=1}^{N}\n\\{x_i\\}_{i=1}^{N}\n, \n\\{p_i\\}_{i=1}^{N}\n\\{p_i\\}_{i=1}^{N}\n, and \n\\{\\Lambda_i\\}_{i=1}^{N}\n\\{\\Lambda_i\\}_{i=1}^{N}\n along the prediction horizon into \nDoP\n pieces:\n\nsizeSeg\n     \n=\n \nN\n/\nDoP\n;\n\n\nlambdaSplit\n \n=\n \nreshape\n(\nlambda\n,\n \nlambdaDim\n,\n  \nsizeSeg\n,\nDoP\n);\n\n\nmuSplit\n     \n=\n \nreshape\n(\nmu\n,\n     \nmuDim\n,\n      \nsizeSeg\n,\nDoP\n);\n\n\nuSplit\n      \n=\n \nreshape\n(\nu\n,\n      \nuDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\nxSplit\n      \n=\n \nreshape\n(\nx\n,\n      \nxDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\npSplit\n      \n=\n \nreshape\n(\npar\n,\n    \npDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\nLAMBDASplit\n \n=\n \nreshape\n(\nLAMBDA\n,\n \nxDim\n,\n \nxDim\n,\n \nsizeSeg\n,\nDoP\n);\n\n\n\n\n\n\n\n\nGenerate DLL and copy it to the working directory:\n\nargs_NMPC_Iter\n \n=\n \n{\nx0\n,\n...\n\n                  \nlambdaSplit\n,\n...\n\n                  \nmuSplit\n,\n...\n\n                  \nuSplit\n,\n...\n\n                  \nxSplit\n,\n...\n\n                  \npSplit\n,\n...\n\n                  \nLAMBDASplit\n,\n...\n\n                  \ncoder\n.\nConstant\n(\ndiscretizationMethod\n),\n...\n\n                  \ncoder\n.\nConstant\n(\nisMEnabled\n)};\n\n\nNMPC_Iter_CodeGen\n(\ndll\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\ncopyfile\n(\n./codegen/dll/NMPC_Iter/NMPC_Iter.dll\n);\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\n./Simu_Simulink.slx\n\n\n\n\n\n\nNote\n\n\nThis example shows how to call the generated C interface in Simulink using the \ncoder.cevel\n function within a \nMATLAB Function\n block. \nYou can also call the C/C++ interface utilizing S-function.\n\n\n\n\n\n\n\n\nOpen the Simulation Target pane in the Simulink Editor:\n\nSimulation \n Model Configuration Parameters \n Simulation Target\n.\n\n\n\n\n\n\nAdd \n#include\n \nNMPC_Iter.h\n to \nInsert custom C code in generated: Header file\n.\n\n\n\n\n\n\nAdd the following directories to \nAdditional Build Information: Include directories\n:\n\n./\ncodegen\n/\ndll\n/\nNMPC_Iter\n\n\n./\ncodegen\n/\nlib\n/\nOCP_F_Fu_Fx\n\n\n\n\n\n\n\n\nAdd \nNMPC_Iter.lib\n to \nAdditional Build Information: Libraries\n.\n\n\n\n\n\n\nCall the generated C function in a \nMATLAB Function\n block in Simulink:\n\ncoder\n.\nceval\n(\nNMPC_Iter\n,\n...\n\n             \nx0\n,\n...\n\n             \ncoder\n.\nref\n(\nlambdaSplit\n),\n...\n\n             \ncoder\n.\nref\n(\nmuSplit\n),\n... (optional)\n\n             \ncoder\n.\nref\n(\nuSplit\n),\n...\n\n             \ncoder\n.\nref\n(\nxSplit\n),\n...\n\n             \ncoder\n.\nref\n(\npSplit\n),\n...  (optional)\n\n             \ncoder\n.\nref\n(\nLAMBDASplit\n),\n...\n\n             \ncoder\n.\nwref\n(\ncost\n),\n...\n\n             \ncoder\n.\nwref\n(\nerror\n),\n...\n\n             \ncoder\n.\nwref\n(\ntimeElapsed\n));\n\n\n\n\n\n\n\n\nFile Dependency\n\n\n\n\n\n\n\n\n\nLegend\uff1a\n\n\n\n\n\n\n\nAdvanced Functions\n\n\n\n\n\n\nFrom the file dependency, you can even edit directly, e.g., \nOCP_F_Fu_Fx\n, to specify your own dynamic function \nF(u,x,p)\nF(u,x,p)\n, and its Jacobians \n\\partial F/\\partial u\n\\partial F/\\partial u\n and \n\\partial F/\\partial x\n\\partial F/\\partial x\n rather than using the auto-generated \nOCP_GEN_~.m\n.\n\n\n\n\n\n\nCurrently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling \nSIM_GEN_~.m\n.", 
            "title": "Workflow"
        }, 
        {
            "location": "/workflow/#workflow-of-parnmpc", 
            "text": "", 
            "title": "Workflow of ParNMPC"
        }, 
        {
            "location": "/workflow/#preparation", 
            "text": "Choose a compiler that supports parallel code generation by  mex -setup .  Edit  Timer.m  to specify the timer function that measures the current time for your own platform.", 
            "title": "Preparation"
        }, 
        {
            "location": "/workflow/#nmpc-problem-formulation", 
            "text": "Example  ./NMPC_Problem_Definition.m     Formulate an OCP using Class  OptimalControlProblem  % Create an OptimalControlProblem object  OCP   =   OptimalControlProblem ( muDim , ... % constraints dim \n                             uDim , ...  % inputs dim \n                             xDim , ...  % states dim \n                             pDim , ...  % parameters dim (position reference) \n                             T , ...     % prediction horizon \n                             N );         % num of discritization grids  % Give names to x, u, p (optional)                            [ ~ ]   =   OCP . setStateName ( ~ );  [ ~ ]   =   OCP . setInputName ( ~ );  [ ~ ]   =   OCP . setParameterName ( ~ );  % Reset the prediction horizon T   % (optional for variable horizon or nonuniform discretization)  OCP . setT ( ~ );  % Set the dynamic function f  OCP . setf ( ~ );  % Set the matrix M (optional for, e.g., Lagrange model)  OCP . setM ( ~ );  % Set the equality constraint function C (optional)  OCP . setC ( ~ );  % Set the cost function L  OCP . setL ( ~ );  % Generate necessary files  OCP . codeGen ();     Configrate the solver using Class  NMPCSolver  % Create a NMPCSolver object  nmpcSolver   =   NMPCSolver ( OCP );  % Configurate the Hessian approximation method  nmpcSolver . setHessianApproximation ( ~ );  % Generate necessary files  nmpcSolver . codeGen ();     Solve the very first OCP for a given initial state and given parameters using Class  OCPSolver  % Set the initial state       x0   =   [ ~ ];  % Set the parameters          par   =   [ ~ ];  % Create an OCPSolver object  ocpSolver   =   OCPSolver ( OCP , nmpcSolver , x0 , par );  % Choose one of the following methods to provide an initial guess:  % 1. init guess by input  lambdaInitGuess   =   [ ~ ];  muInitGuess       =   [ ~ ];  uInitGuess        =   [ ~ ];  xInitGuess        =   [ ~ ];  % 2. init guess by interpolation  [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ]   =   ... \n     ocpSolver . initFromStartEnd ( ~ );  % 3. init guess from file  [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ]   =   ... \n                         ocpSolver . initFromMatFile ( ~ );  % Solve the OCP                       [ lambda , mu , u , x ]   =   ocpSolver . OCPSolve ( lambdaInitGuess , ... \n                                      muInitGuess , ... \n                                      uInitGuess , ... \n                                      xInitGuess , ... \n                                      method );  % Get the dependent variable LAMBDA  LAMBDA   =   ocpSolver . getLAMBDA ( x0 , lambda , mu , u , x , par );  % Check the cost % (optional)  cost   =   ocpSolver . getCost ( u , x , par );   % Save to file for further use  save   GEN_initData . mat    ... \n      x0   lambda   mu   u   x   par   LAMBDA   ~     Define the controlled plant using Class  DynamicSystem  (optional for simulation) % Create a DynamicSystem object  plant   =   DynamicSystem ( uDim , xDim , pDim );  % Give names to x, u, p (optional)  [ ~ ]   =   plant . setStateName ( ~ );  [ ~ ]   =   plant . setInputName ( ~ );  [ ~ ]   =   plant . setParameterName ( ~ );  % Set the dynamic function f  plant . setf ( ~ );  % Set the matrix M (optional for, e.g., Lagrange model)  plant . setM ( ~ );  % Generate necessary files  plant . codeGen ();     Configuration Table:     Situation  Configurable discretization method  Configurable Hessian approximation method      M  enabled  Euler  GaussNewton    M  disabled  Euler ,  RK4  Newton ,  GaussNewton  when  Euler ; GaussNewton  when  RK4 ;", 
            "title": "NMPC Problem Formulation "
        }, 
        {
            "location": "/workflow/#code-generation-and-deployment", 
            "text": "", 
            "title": "Code Generation and Deployment"
        }, 
        {
            "location": "/workflow/#matlab", 
            "text": "Assume that you have written a MATLAB function to carry out the closed-loop simulation for your problem defined above using the functions provided by ParNMPC, that is,  NMPC_Iter  is used to calculate the optimal control input, and  SIM_Plant_RK4  is used to simulate the controlled plant.   Example  ./Simu_Matlab.m", 
            "title": "MATLAB"
        }, 
        {
            "location": "/workflow/#code-generation", 
            "text": "Assume that you have run  NMPC_Problem_Formulation.m .\nNext, the code generation process using the MATLAB Coder App for this simulation is shown.     Open the MATLAB Coder App.    Select  Simu_Matlab.m .    Click the  Generate  button, and the C code will be automatically generated to  ./codegen/lib/Simu_Matlab .", 
            "title": "Code generation"
        }, 
        {
            "location": "/workflow/#deployment-in-visual-studio", 
            "text": "Create an empty Win32 Console Application project.    Change to Release x64 mode.    Add   *.h  and  *.c  files in  .\\codegen\\lib\\Simu_Matlab  to the project.    Add   main.h  and  main.c  in  .\\codegen\\lib\\Simu_Matlab\\examples  to the project.    Add   OCP_F_Fu_Fx.h  and  OCP_F_Fu_Fx.c  in  .\\codegen\\lib\\OCP_F_Fu_Fx  to the project.    Add directories  .\\codegen\\lib\\Simu_Matlab  and  .\\codegen\\lib\\OCP_F_Fu_Fx  to  Properties   C/C++   General    Additional Include Directories .    Properties   C/C++   Language    Open MP Support: Yes (/openmp) .    Compile and run.", 
            "title": "Deployment in Visual Studio"
        }, 
        {
            "location": "/workflow/#simulink", 
            "text": "When doing the closed-loop simulation in Simulink, you can call the generated C/C++ solver function  NMPC_Iter  directly to compute the optimal input.", 
            "title": "Simulink "
        }, 
        {
            "location": "/workflow/#code-generation_1", 
            "text": "Example  ./Simu_Simulink_Setup.m     Define the degree of parallelism: DoP   =   ~ ;   % degree of parallism: 1 = in serial, otherwise in parallel     Split  \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} ,  \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} ,  \\{u_i\\}_{i=1}^{N} \\{u_i\\}_{i=1}^{N} ,  \\{x_i\\}_{i=1}^{N} \\{x_i\\}_{i=1}^{N} ,  \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} , and  \\{\\Lambda_i\\}_{i=1}^{N} \\{\\Lambda_i\\}_{i=1}^{N}  along the prediction horizon into  DoP  pieces: sizeSeg       =   N / DoP ;  lambdaSplit   =   reshape ( lambda ,   lambdaDim ,    sizeSeg , DoP );  muSplit       =   reshape ( mu ,       muDim ,        sizeSeg , DoP );  uSplit        =   reshape ( u ,        uDim ,         sizeSeg , DoP );  xSplit        =   reshape ( x ,        xDim ,         sizeSeg , DoP );  pSplit        =   reshape ( par ,      pDim ,         sizeSeg , DoP );  LAMBDASplit   =   reshape ( LAMBDA ,   xDim ,   xDim ,   sizeSeg , DoP );     Generate DLL and copy it to the working directory: args_NMPC_Iter   =   { x0 , ... \n                   lambdaSplit , ... \n                   muSplit , ... \n                   uSplit , ... \n                   xSplit , ... \n                   pSplit , ... \n                   LAMBDASplit , ... \n                   coder . Constant ( discretizationMethod ), ... \n                   coder . Constant ( isMEnabled )};  NMPC_Iter_CodeGen ( dll , C , args_NMPC_Iter );  copyfile ( ./codegen/dll/NMPC_Iter/NMPC_Iter.dll );", 
            "title": "Code generation"
        }, 
        {
            "location": "/workflow/#deployment", 
            "text": "Example  ./Simu_Simulink.slx    Note  This example shows how to call the generated C interface in Simulink using the  coder.cevel  function within a  MATLAB Function  block. \nYou can also call the C/C++ interface utilizing S-function.     Open the Simulation Target pane in the Simulink Editor: Simulation   Model Configuration Parameters   Simulation Target .    Add  #include   NMPC_Iter.h  to  Insert custom C code in generated: Header file .    Add the following directories to  Additional Build Information: Include directories : ./ codegen / dll / NMPC_Iter  ./ codegen / lib / OCP_F_Fu_Fx     Add  NMPC_Iter.lib  to  Additional Build Information: Libraries .    Call the generated C function in a  MATLAB Function  block in Simulink: coder . ceval ( NMPC_Iter , ... \n              x0 , ... \n              coder . ref ( lambdaSplit ), ... \n              coder . ref ( muSplit ), ... (optional) \n              coder . ref ( uSplit ), ... \n              coder . ref ( xSplit ), ... \n              coder . ref ( pSplit ), ...  (optional) \n              coder . ref ( LAMBDASplit ), ... \n              coder . wref ( cost ), ... \n              coder . wref ( error ), ... \n              coder . wref ( timeElapsed ));", 
            "title": "Deployment"
        }, 
        {
            "location": "/workflow/#file-dependency", 
            "text": "Legend\uff1a", 
            "title": "File Dependency"
        }, 
        {
            "location": "/workflow/#advanced-functions", 
            "text": "From the file dependency, you can even edit directly, e.g.,  OCP_F_Fu_Fx , to specify your own dynamic function  F(u,x,p) F(u,x,p) , and its Jacobians  \\partial F/\\partial u \\partial F/\\partial u  and  \\partial F/\\partial x \\partial F/\\partial x  rather than using the auto-generated  OCP_GEN_~.m .    Currently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling  SIM_GEN_~.m .", 
            "title": "Advanced Functions"
        }, 
        {
            "location": "/exp_damper/", 
            "text": "Semi-active Damper\n\n\n\n\nExample\n\n\nSemiActiveDamper/\n\n\n\n\nProblem Description\n\n\nA vehicle contacts the wall through the spring and damper: \n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the system is \nx=[y,\\dot{y}]^T\nx=[y,\\dot{y}]^T\n, where \ny\ny\n is the position of the vehicle. \n\n\n\n\n\n\nThe input is the damping coefficient \nd\nd\n, which is constrained with  \n0\\leq d \\leq 1\n0\\leq d \\leq 1\n.\n\n\n\n\n\n\nThe dynamic equation of this semi-active damper is \nm\\ddot{y} = -ky-d\\dot{y}\nm\\ddot{y} = -ky-d\\dot{y}\n, where \nk = 1\nk = 1\n and \nm=1\nm=1\n.\n\n\n\n\n\n\nThe task is to control the vehicle's position \ny\ny\n to 0 from an initial position.\n\n\nOCP in \nParNMPC\n\n\nThe inequality constraints are transfered into equality constraints by introducing an extra dummy input \nd_s\nd_s\n. \n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[y,\\dot{y}]^T\nx=[y,\\dot{y}]^T\n.\n\n\nInput: \nu=[d,d_s]\nu=[d,d_s]\n.\n\n\nParameter: \np\np\n is empty.\n\n\nL(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s\nL(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s\n.\n\n\nC(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4}\nC(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4}\n.\n\n\nf(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T\nf(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T\n.\n\n\nPrediction horizon \nT=5\nT=5\n.\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler in reverse time (backward Euler).\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nSemiActiveDamper/NMPC_Problem_Definition.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Simulink.slx\n\n\n\n\n\n\n\n\nStep 2. Speed up the closed-loop simulation in Matlab using \nmex\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Simulink_Setup.m\n\n\n\n\nModify the generation target to \nmex\n:\n\nNMPC_Iter_CodeGen\n(\nmex\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\n\nand run.\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Matlab.m\n\n\n\n\nModify \nNMPC_Iter\n to \nNMPC_Iter_mex\n to call the generated \nmex\n function:\n\n[\nlambdaSplit\n,\nmuSplit\n,\nuSplit\n,\nxSplit\n,\n...\n\n \nLAMBDASplit\n,\ncost\n,\nerror\n,\ntimeElapsed\n]\n \n=\n\n \nNMPC_Iter_mex\n(\nx0\n,\nlambdaSplit\n,\nmuSplit\n,\n...\n\n               \nuSplit\n,\nxSplit\n,\npSplit\n,\n...\n\n               \nLAMBDASplit\n,\ndiscretizationMethod\n,\n...\n\n               \nisMEnabled\n);\n\n\n\nand run.", 
            "title": "Simulation: Semi-active Damper"
        }, 
        {
            "location": "/exp_damper/#semi-active-damper", 
            "text": "Example  SemiActiveDamper/", 
            "title": "Semi-active Damper"
        }, 
        {
            "location": "/exp_damper/#problem-description", 
            "text": "A vehicle contacts the wall through the spring and damper:        The state vector of the system is  x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where  y y  is the position of the vehicle.     The input is the damping coefficient  d d , which is constrained with   0\\leq d \\leq 1 0\\leq d \\leq 1 .    The dynamic equation of this semi-active damper is  m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where  k = 1 k = 1  and  m=1 m=1 .    The task is to control the vehicle's position  y y  to 0 from an initial position.", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_damper/#ocp-in-parnmpc", 
            "text": "The inequality constraints are transfered into equality constraints by introducing an extra dummy input  d_s d_s .   The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T .  Input:  u=[d,d_s] u=[d,d_s] .  Parameter:  p p  is empty.  L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s .  C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} .  f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T .  Prediction horizon  T=5 T=5 .  Number of the discritization grids  N=48 N=48 .  Discretization method: Euler in reverse time (backward Euler).", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_damper/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_damper/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  SemiActiveDamper/NMPC_Problem_Definition.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_damper/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  SemiActiveDamper/Simu_Simulink_Setup.m     Deployment   Example  SemiActiveDamper/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_damper/#step-2-speed-up-the-closed-loop-simulation-in-matlab-using-mex", 
            "text": "Code generation   Example  SemiActiveDamper/Simu_Simulink_Setup.m   Modify the generation target to  mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter );  \nand run.    Deployment   Example  SemiActiveDamper/Simu_Matlab.m   Modify  NMPC_Iter  to  NMPC_Iter_mex  to call the generated  mex  function: [ lambdaSplit , muSplit , uSplit , xSplit , ... \n  LAMBDASplit , cost , error , timeElapsed ]   = \n  NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... \n                uSplit , xSplit , pSplit , ... \n                LAMBDASplit , discretizationMethod , ... \n                isMEnabled );  \nand run.", 
            "title": "Step 2. Speed up the closed-loop simulation in Matlab using mex"
        }, 
        {
            "location": "/exp_double_pendulum/", 
            "text": "Double Inverted Pendulum on a Cart\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/\n\n\n\n\n\n\nWhere you can find this system\n\n\nA. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.\n\n\n\n\nProblem Description\n\n\nSwing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. \nThe pendulum we want to swing up is:\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the system is \nx =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T}\nx =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T}\n, where \n\\theta_0\n\\theta_0\n is the displacement of the cart, and where \n\\theta_1\n\\theta_1\n, \n\\theta_2\n\\theta_2\n are the pendulum angles. The displacement \n\\theta_0\n\\theta_0\n  is constrained with \n|\\theta_0|\\leq 0.2\n|\\theta_0|\\leq 0.2\n m\n\n\n\n\n\n\nThe control force \nu\nu\n is constrained with  \n|u|\\leq 15\n|u|\\leq 15\n.\n\n\n\n\n\n\nThe system is modeled as \nD(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu\nD(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu\n with \n\\theta=[\\theta_0,\\theta_1,\\theta_2]^T\n\\theta=[\\theta_0,\\theta_1,\\theta_2]^T\n.\n\n\n\n\n\n\nA terminal penalty function is imposed to swing up the pendulum.\n\n\n\n\n\n\nThe task is to swing up the pendulum from the initial state \nx_0 =  [0,\\pi,\\pi,0,0,0]^{T}\nx_0 =  [0,\\pi,\\pi,0,0,0]^{T}\n.\n\n\nOCP in \nParNMPC\n\n\nThe inequality constraints on the input \nu\nu\n are handled using the logarithmic barrier functions, and the inequality constraints on \n\\theta_0\n\\theta_0\n are softened using the KS functions.\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T\nx=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T\n.\n\n\nInput: \nu\nu\n.\n\n\nParameter: \np=[Q_d,R_d,\\gamma_u,\\gamma_{\\theta_0},\\beta_{\\theta_0}]\np=[Q_d,R_d,\\gamma_u,\\gamma_{\\theta_0},\\beta_{\\theta_0}]\n.\n\n\n\n\nL(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) + L_{\\theta_0}(u,x,p)\nL(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) + L_{\\theta_0}(u,x,p)\n, where \nL_s(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2\nL_s(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2\n with \nQ=\\text{diag}(Q_d)\nQ=\\text{diag}(Q_d)\n and \nR=\\text{diag}(R_d)\nR=\\text{diag}(R_d)\n, \nL_u(u,x,p) = -\\gamma_u\\text{log}(1-u)-\\gamma_u\\text{log}(u)\nL_u(u,x,p) = -\\gamma_u\\text{log}(1-u)-\\gamma_u\\text{log}(u)\n, and \nL_{\\theta_0}(u,x,p) = \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(\\theta_0-0.19)}) + \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(-0.19-\\theta_0)})\nL_{\\theta_0}(u,x,p) = \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(\\theta_0-0.19)}) + \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(-0.19-\\theta_0)})\n.\n\n\n\n\n\n\nf(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}]\nf(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}]\n.\n\n\n\n\n\n\nM(u,x,p) = \\text{blkdiag}(eye(3),D(\\theta))\nM(u,x,p) = \\text{blkdiag}(eye(3),D(\\theta))\n.\n\n\n\n\n\n\nPrediction horizon \nT=1.5\nT=1.5\n.\n\n\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler in reverse time (backward Euler).\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/NMPC_Problem_Definition.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Simulink.slx\n\n\n\n\n\n\n\n\nStep 2. Speed up the closed-loop simulation in Matlab using \nmex\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Simulink_Setup.m\n\n\n\n\nModify the generation target to \nmex\n:\n\nNMPC_Iter_CodeGen\n(\nmex\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\n\nand run.\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Matlab.m\n\n\n\n\nModify \nNMPC_Iter\n to \nNMPC_Iter_mex\n to call the generated \nmex\n function:\n\n[\nlambdaSplit\n,\nmuSplit\n,\nuSplit\n,\nxSplit\n,\n...\n\n \nLAMBDASplit\n,\ncost\n,\nerror\n,\ntimeElapsed\n]\n \n=\n\n \nNMPC_Iter_mex\n(\nx0\n,\nlambdaSplit\n,\nmuSplit\n,\n...\n\n               \nuSplit\n,\nxSplit\n,\npSplit\n,\n...\n\n               \nLAMBDASplit\n,\ndiscretizationMethod\n,\n...\n\n               \nisMEnabled\n);\n\n\n\nand run.", 
            "title": "Simulation: Double Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_double_pendulum/#double-inverted-pendulum-on-a-cart", 
            "text": "Example  DoubleInvertedPendulum/    Where you can find this system  A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.", 
            "title": "Double Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_double_pendulum/#problem-description", 
            "text": "Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. \nThe pendulum we want to swing up is:       The state vector of the system is  x =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T} x =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T} , where  \\theta_0 \\theta_0  is the displacement of the cart, and where  \\theta_1 \\theta_1 ,  \\theta_2 \\theta_2  are the pendulum angles. The displacement  \\theta_0 \\theta_0   is constrained with  |\\theta_0|\\leq 0.2 |\\theta_0|\\leq 0.2  m    The control force  u u  is constrained with   |u|\\leq 15 |u|\\leq 15 .    The system is modeled as  D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu  with  \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T .    A terminal penalty function is imposed to swing up the pendulum.    The task is to swing up the pendulum from the initial state  x_0 =  [0,\\pi,\\pi,0,0,0]^{T} x_0 =  [0,\\pi,\\pi,0,0,0]^{T} .", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_double_pendulum/#ocp-in-parnmpc", 
            "text": "The inequality constraints on the input  u u  are handled using the logarithmic barrier functions, and the inequality constraints on  \\theta_0 \\theta_0  are softened using the KS functions.  The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T .  Input:  u u .  Parameter:  p=[Q_d,R_d,\\gamma_u,\\gamma_{\\theta_0},\\beta_{\\theta_0}] p=[Q_d,R_d,\\gamma_u,\\gamma_{\\theta_0},\\beta_{\\theta_0}] .   L(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) + L_{\\theta_0}(u,x,p) L(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) + L_{\\theta_0}(u,x,p) , where  L_s(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 L_s(u,x,p) = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2  with  Q=\\text{diag}(Q_d) Q=\\text{diag}(Q_d)  and  R=\\text{diag}(R_d) R=\\text{diag}(R_d) ,  L_u(u,x,p) = -\\gamma_u\\text{log}(1-u)-\\gamma_u\\text{log}(u) L_u(u,x,p) = -\\gamma_u\\text{log}(1-u)-\\gamma_u\\text{log}(u) , and  L_{\\theta_0}(u,x,p) = \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(\\theta_0-0.19)}) + \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(-0.19-\\theta_0)}) L_{\\theta_0}(u,x,p) = \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(\\theta_0-0.19)}) + \\beta_{\\theta_0}\\text{log}(1+e^{\\frac{1}{\\gamma_{\\theta_0}}(-0.19-\\theta_0)}) .    f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] .    M(u,x,p) = \\text{blkdiag}(eye(3),D(\\theta)) M(u,x,p) = \\text{blkdiag}(eye(3),D(\\theta)) .    Prediction horizon  T=1.5 T=1.5 .   Number of the discritization grids  N=48 N=48 .  Discretization method: Euler in reverse time (backward Euler).", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_double_pendulum/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_double_pendulum/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  DoubleInvertedPendulum/NMPC_Problem_Definition.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_double_pendulum/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  DoubleInvertedPendulum/Simu_Simulink_Setup.m     Deployment   Example  DoubleInvertedPendulum/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_double_pendulum/#step-2-speed-up-the-closed-loop-simulation-in-matlab-using-mex", 
            "text": "Code generation   Example  DoubleInvertedPendulum/Simu_Simulink_Setup.m   Modify the generation target to  mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter );  \nand run.    Deployment   Example  DoubleInvertedPendulum/Simu_Matlab.m   Modify  NMPC_Iter  to  NMPC_Iter_mex  to call the generated  mex  function: [ lambdaSplit , muSplit , uSplit , xSplit , ... \n  LAMBDASplit , cost , error , timeElapsed ]   = \n  NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... \n                uSplit , xSplit , pSplit , ... \n                LAMBDASplit , discretizationMethod , ... \n                isMEnabled );  \nand run.", 
            "title": "Step 2. Speed up the closed-loop simulation in Matlab using mex"
        }, 
        {
            "location": "/exp_quadrotor/", 
            "text": "Quadrotor\n\n\n\n\nExample\n\n\nQuadrotor/\n\n\n\n\n\n\nWhere you can find this system\n\n\nM. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d \nICRA, Shanghai, China, 2011, pp. 763\u2013770.\n\n\n\n\nProblem Description\n\n\nThe quadrotor we want to control is like this:\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the quadrotor is \nx =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9}\nx =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9}\n, where \n(X,Y,Z)\n(X,Y,Z)\n and \n(\\gamma,\\beta,\\alpha)\n(\\gamma,\\beta,\\alpha)\n are the position and angles of the quadrotor, respectively. \n\n\n\n\n\n\nThe input vector is \nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T\nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T\n, where \na\na\n represents the thrust and \n(\\omega_{X},\\omega_{Y},\\omega_{Z})\n(\\omega_{X},\\omega_{Y},\\omega_{Z})\n the rotational rates. The control input is bounded by \nu_{min}=[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T = u_{max}\nu_{min}=[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T = u_{max}\n.\n\n\n\n\n\n\nThe dynamics of the quadrotor are given by the following equations:\n\n\n\n\n\n\n\n\n\\begin{align}\n\n\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n\n\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n\n\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n\n\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n\n\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n\n\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}\n\n\n\\begin{align}\n&\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n&\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n&\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n&\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n&\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n&\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}\n\n\n\n\nThe task is to use NMPC to control the quadrotor to track the given position reference under a variable prediction horizon.\n\n\nOCP in \nParNMPC\n\n\nThe inequality constraints are handled using the logarithmic barrier functions.\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T\nx=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T\n.\n\n\nInput: \nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]\nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]\n.\n\n\nParameter: \np=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T\np=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T\n, where \n\\gamma\n0\n\\gamma>0\n is the barrier parameter.\n\n\nL(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p)\nL(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p)\n, where \nL_s(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\nL_s(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\n with \nx_{ref}=\\text{diag}([X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0])\nx_{ref}=\\text{diag}([X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0])\n, and \nL_u(u,x,p)\nL_u(u,x,p)\n is the summation of the  barrier functions with parameters \n\\gamma\n\\gamma\n.\n\n\nf(u,x,p)\nf(u,x,p)\n is shown before.\n\n\nPrediction horizon \nT\nT\n.\n\n\nNumber of the discritization grids \nN=40\nN=40\n.\n\n\nDiscretization method: Euler in reverse time (backward Euler).\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nQuadrotor/NMPC_Problem_Definition.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Simulink.slx\n\n\n\n\n\n\n\n\nStep 2. Speed up the closed-loop simulation in Matlab using \nmex\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Simulink_Setup.m\n\n\n\n\nModify the generation target to \nmex\n:\n\nNMPC_Iter_CodeGen\n(\nmex\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\n\nand run.\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Matlab.m\n\n\n\n\nModify \nNMPC_Iter\n to \nNMPC_Iter_mex\n to call the generated \nmex\n function:\n\n[\nlambdaSplit\n,\nmuSplit\n,\nuSplit\n,\nxSplit\n,\n...\n\n \nthetaSplit\n,\ncost\n,\nerror\n,\ntimeElapsed\n]\n \n=\n\n \nNMPC_Iter_mex\n(\nx0\n,\nlambdaSplit\n,\nmuSplit\n,\n...\n\n               \nuSplit\n,\nxSplit\n,\npSplit\n,\n...\n\n               \nthetaSplit\n,\ndiscretizationMethod\n,\n...\n\n               \nisMEnabled\n);\n\n\n\nand run.", 
            "title": "Simulation: Quadrotor"
        }, 
        {
            "location": "/exp_quadrotor/#quadrotor", 
            "text": "Example  Quadrotor/    Where you can find this system  M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d \nICRA, Shanghai, China, 2011, pp. 763\u2013770.", 
            "title": "Quadrotor"
        }, 
        {
            "location": "/exp_quadrotor/#problem-description", 
            "text": "The quadrotor we want to control is like this:       The state vector of the quadrotor is  x =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where  (X,Y,Z) (X,Y,Z)  and  (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha)  are the position and angles of the quadrotor, respectively.     The input vector is  u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where  a a  represents the thrust and  (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z})  the rotational rates. The control input is bounded by  u_{min}=[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T = u_{max} u_{min}=[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T = u_{max} .    The dynamics of the quadrotor are given by the following equations:     \\begin{align} \\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ \\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ \\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ \\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ \\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ \\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}  \\begin{align}\n&\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n&\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n&\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n&\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n&\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n&\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}   The task is to use NMPC to control the quadrotor to track the given position reference under a variable prediction horizon.", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_quadrotor/#ocp-in-parnmpc", 
            "text": "The inequality constraints are handled using the logarithmic barrier functions.  The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T x=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T .  Input:  u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}] u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}] .  Parameter:  p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T , where  \\gamma 0 \\gamma>0  is the barrier parameter.  L(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) L(u,x,p) = L_s(u,x,p) + L_{u}(u,x,p) , where  L_s(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_s(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2  with  x_{ref}=\\text{diag}([X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]) x_{ref}=\\text{diag}([X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]) , and  L_u(u,x,p) L_u(u,x,p)  is the summation of the  barrier functions with parameters  \\gamma \\gamma .  f(u,x,p) f(u,x,p)  is shown before.  Prediction horizon  T T .  Number of the discritization grids  N=40 N=40 .  Discretization method: Euler in reverse time (backward Euler).", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_quadrotor/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_quadrotor/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  Quadrotor/NMPC_Problem_Definition.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_quadrotor/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  Quadrotor/Simu_Simulink_Setup.m     Deployment   Example  Quadrotor/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_quadrotor/#step-2-speed-up-the-closed-loop-simulation-in-matlab-using-mex", 
            "text": "Code generation   Example  Quadrotor/Simu_Simulink_Setup.m   Modify the generation target to  mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter );  \nand run.    Deployment   Example  Quadrotor/Simu_Matlab.m   Modify  NMPC_Iter  to  NMPC_Iter_mex  to call the generated  mex  function: [ lambdaSplit , muSplit , uSplit , xSplit , ... \n  thetaSplit , cost , error , timeElapsed ]   = \n  NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... \n                uSplit , xSplit , pSplit , ... \n                thetaSplit , discretizationMethod , ... \n                isMEnabled );  \nand run.", 
            "title": "Step 2. Speed up the closed-loop simulation in Matlab using mex"
        }, 
        {
            "location": "/exp_single_pendulum/", 
            "text": "Single Inverted Pendulum on a Cart\n\n\nComing soon.", 
            "title": "Experiment: Single Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_single_pendulum/#single-inverted-pendulum-on-a-cart", 
            "text": "Coming soon.", 
            "title": "Single Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_heli/", 
            "text": "Helicopter\n\n\nComing soon.\n\n\nQuanser: 3 DoF Helicopter", 
            "title": "Experiment: Helicopter"
        }, 
        {
            "location": "/exp_heli/#helicopter", 
            "text": "Coming soon.  Quanser: 3 DoF Helicopter", 
            "title": "Helicopter"
        }, 
        {
            "location": "/tips/", 
            "text": "Tips\n\n\nHandling Inquality Constraint \n\n\nAssume we have an inequality constraint \nG(x)\\leq 0\nG(x)\\leq 0\n, it can be transferred into \nG(x)= v\nG(x)= v\n with \nv\\leq 0\nv\\leq 0\n. Here are several methods dealing with inequality constraint:\n\n\n\n\n\n\nInterior point method\n\n\n\n\nBarrier function, e.g., logarithmic:\n\n-\\gamma\\text{log}(-v)\n-\\gamma\\text{log}(-v)\n, \n\\gamma\n\\gamma\n is a free parameter.\n\n\nSoft barrier function, e.g., Kreisselmeier-Steinhauser (KS) function:  \n\\beta\\text{log}(1+e^{\\gamma v})\n\\beta\\text{log}(1+e^{\\gamma v})\n.\n\n\n\n\n\n\n\n\nTo equality constraint: \nv+d^2 = 0\nv+d^2 = 0\n, \nd\nd\n is a slack variable.\n\n\n\n\n\n\nSolving the Very First OCP\n\n\nIn most of the cases, the very first OCP can be solved offline and its solution can be used as warm start. In solving the very first OCP offline, you can start with a mild parameter and then gradually change it to the parameter you want.\n\n\nDegree of Parallelism (DoP)\n\n\nDoP\n is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller \nDoP\n. In the case of \nDoP=1\n, a full step Newton or Gauss-Newton iteration (depending on the Hessian approximation method) is performed.\n\n\nMeanwhile, when you want to generate serial code without any parallel computing, you can set \nDoP\n to 1 and edit \nTimer.m\n to specify your own timer function (the default is \nomp_get_wtime\n).\n\n\nTuning\n\n\n\n\nSpecify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.", 
            "title": "Tips"
        }, 
        {
            "location": "/tips/#tips", 
            "text": "", 
            "title": "Tips"
        }, 
        {
            "location": "/tips/#handling-inquality-constraint", 
            "text": "Assume we have an inequality constraint  G(x)\\leq 0 G(x)\\leq 0 , it can be transferred into  G(x)= v G(x)= v  with  v\\leq 0 v\\leq 0 . Here are several methods dealing with inequality constraint:    Interior point method   Barrier function, e.g., logarithmic: -\\gamma\\text{log}(-v) -\\gamma\\text{log}(-v) ,  \\gamma \\gamma  is a free parameter.  Soft barrier function, e.g., Kreisselmeier-Steinhauser (KS) function:   \\beta\\text{log}(1+e^{\\gamma v}) \\beta\\text{log}(1+e^{\\gamma v}) .     To equality constraint:  v+d^2 = 0 v+d^2 = 0 ,  d d  is a slack variable.", 
            "title": "Handling Inquality Constraint "
        }, 
        {
            "location": "/tips/#solving-the-very-first-ocp", 
            "text": "In most of the cases, the very first OCP can be solved offline and its solution can be used as warm start. In solving the very first OCP offline, you can start with a mild parameter and then gradually change it to the parameter you want.", 
            "title": "Solving the Very First OCP"
        }, 
        {
            "location": "/tips/#degree-of-parallelism-dop", 
            "text": "DoP  is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller  DoP . In the case of  DoP=1 , a full step Newton or Gauss-Newton iteration (depending on the Hessian approximation method) is performed.  Meanwhile, when you want to generate serial code without any parallel computing, you can set  DoP  to 1 and edit  Timer.m  to specify your own timer function (the default is  omp_get_wtime ).", 
            "title": "Degree of Parallelism (DoP)"
        }, 
        {
            "location": "/tips/#tuning", 
            "text": "Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.", 
            "title": "Tuning"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nParNMPC\n is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.\n\n\nCiting ParNMPC\n\n\nComing soon.\n\n\nContributing\n\n\nParNMPC\n is an open-source project, and you are highly welcome to make contributions. \n\n\nContacting Us\n\n\nPlease do not hesitate to contact us if you have any questions.\nWe would be very happy to hear your advices, experiences, stories, and contributions.\n\n\nYou can contact us by:\n\n\n\n\nposting an issue on \nParNMPC: Issue\n.\n\n\nE-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp\n\n\njoining our QQ Group: 339029295\n\n\n\n\nLicense\n\n\nParNMPC is distributed under the GNU Lesser General Public License v3.0.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "ParNMPC  is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.", 
            "title": "About"
        }, 
        {
            "location": "/about/#citing-parnmpc", 
            "text": "Coming soon.", 
            "title": "Citing ParNMPC"
        }, 
        {
            "location": "/about/#contributing", 
            "text": "ParNMPC  is an open-source project, and you are highly welcome to make contributions.", 
            "title": "Contributing"
        }, 
        {
            "location": "/about/#contacting-us", 
            "text": "Please do not hesitate to contact us if you have any questions.\nWe would be very happy to hear your advices, experiences, stories, and contributions.  You can contact us by:   posting an issue on  ParNMPC: Issue .  E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp  joining our QQ Group: 339029295", 
            "title": "Contacting Us"
        }, 
        {
            "location": "/about/#license", 
            "text": "ParNMPC is distributed under the GNU Lesser General Public License v3.0.", 
            "title": "License"
        }
    ]
}