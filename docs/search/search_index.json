{
    "docs": [
        {
            "location": "/", 
            "text": "ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC\n\n\nVersion 1808-1 (\nGithub: ParNMPC\n) has been released!\n\n\nIntroduction\n\n\nParNMPC\n is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC).\n\nParNMPC\n can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of \n\\mu\n\\mu\ns). \nThe purpose of \nParNMPC\n is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment.\n\n\nFeatures\n\n\n\n\nSymbolic problem representation\n\n\nAutomatic parallel C/C++ code generation with OpenMP\n\n\nFast rate of convergence (up to be superlinear)\n\n\nHighly parallelizable (capable of using at most N cores, N is the # of discretization steps)\n\n\nHigh speedup ratio\n\n\nMATLAB \n Simulink \n\n\n\n\nProblems Supported in  \nParNMPC\n\n\nThe optimization control problem (OCP) supported in \nParNMPC\n has the following form:\n\n\n\n\n\\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}\n\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad \nx(0) = \\bar{x}_0,\\\\\n\nM\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n\n C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\\n\n u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\\n\n x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\\n\n G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T].\n\\end{align}\n\n\n\\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\\n&M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n& C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\\n& u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\\n& x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\\n& G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T].\n\\end{align}\n\n\n\n\nHere,\n\n\n\n\n\n\n\n\nSign\n\n\nSize\n\n\nDescription\n\n\nSign\n\n\nSize\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nu\nu\n\n\n[uDim,1]\n\n\nInput vector\n\n\nL\nL\n\n\n[1,1]\n\n\nCost function\n\n\n\n\n\n\nx\nx\n\n\n[xDim,1]\n\n\nState vector\n\n\nC\nC\n\n\n[muDim,1]\n\n\nEquality constraint function\n\n\n\n\n\n\np\np\n\n\n[pDim,1]\n\n\nGiven parameter vector\n\n\nf\nf\n\n\n[xDim,1]\n\n\nDynamics\n\n\n\n\n\n\nT\nT\n\n\n[1,1]\n\n\nPrediction horizon\n\n\nM\nM\n\n\n[xDim,xDim]\n\n\n(Optional, e.g., Lagrange model)\n\n\n\n\n\n\n\\bar{x}_0\n\\bar{x}_0\n\n\n[xDim,1]\n\n\nCurrent state vector\n\n\nG\nG\n\n\n[GDim,1]\n\n\nPolytopic constraint function (\nG\nG\n is linear in \nu\nu\n and \nx\nx\n)\n\n\n\n\n\n\nu_{min}\nu_{min}\n\n\n[uDim,1]\n\n\nLower bound of \nu\nu\n\n\nu_{max}\nu_{max}\n\n\n[uDim,1]\n\n\nUpper bound of \nu\nu\n\n\n\n\n\n\nx_{min}\nx_{min}\n\n\n[xDim,1]\n\n\nLower bound of \nx\nx\n\n\nx_{max}\nx_{max}\n\n\n[xDim,1]\n\n\nUpper bound of \nx\nx\n\n\n\n\n\n\nG_{min}\nG_{min}\n\n\n[GDim,1]\n\n\nLower bound of \nG\nG\n\n\nG_{max}\nG_{max}\n\n\n[GDim,1]\n\n\nUpper bound of \nG\nG\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nVarying dynamics, prediction horizon and references, and terminal cost function can be achieved by using the parameter \np\np\n.\n\n\n\n\n\n\nHow \nParNMPC\n Solves the OCP?\n\n\nDiscretization\n\n\nParNMPC\n  discretizes the OCP defined above into the following problem with \nN\nN\n steps:\n\n\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}\nL(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad \n x_0 = \\bar{x}_0,\\\\\n\nF(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\n\nHere, the continuous-time state equation \n\\dot{x}(t)=f(u(t),x(t),p(t))\n\\dot{x}(t)=f(u(t),x(t),p(t))\n (if \nM\nM\n is not imposed) is discretized to be \nF(x_{i-1},u_i,x_i,p_i)=0\nF(x_{i-1},u_i,x_i,p_i)=0\n, e.g., the backward Euler's method with \nF(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i\nF(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i\n, where \n\\Delta\\tau=T/N\n\\Delta\\tau=T/N\n.\n\n\nHandling inequality constraints\n\n\nThe inequality constraints are converted into logarithmic barrier functions (i.e., interior-point method).\nThe following equality-constrained problem is obtained:\n\n\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}\nL(u_i,x_i,p_i)  \\\\\n-\\gamma\\sum_{i=1}^{N}\n\\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}\n\\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}\n\\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\\n\\text{s.t.}\\quad \n x_0 = \\bar{x}_0,\\\\\n\nF(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n\n C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i)  \\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}\n\n\n\n\nHere, \nv_{(j)}\nv_{(j)}\n is the \nj\nj\n-th element of a variable \nv\nv\n, \nG_{i(j)}\nG_{i(j)}\n is the  \nj\nj\n-th element of \nG(u_i,x_i,p_i)\nG(u_i,x_i,p_i)\n, and \n\\gamma\n\\gamma\n is the barrier parameter.\nFor simplicity, the same barrier parameter is used here. It can be set to be different for different constraints in \nParNMPC\n.\n\n\nSolving the KKT conditions iteratively in parallel\n\n\nThen, \nParNMPC\n derives the KKT conditions for the problem above by introducing Lagrange multipliers \n\\{\\lambda_i\\}_{i=1}^{N}\n\\{\\lambda_i\\}_{i=1}^{N}\n for the state equations and \n\\{\\mu_i\\}_{i=1}^{N}\n\\{\\mu_i\\}_{i=1}^{N}\n for the equality constraints.\n\n\nNext, the KKT conditions are solved iteratively in parallel for a given initial state \n\\bar{x}_0\n\\bar{x}_0\n and given parameters \n\\{p_i\\}_{i=1}^{N}\n\\{p_i\\}_{i=1}^{N}\n.\nThe NMPC controller is implemented by applying the first optimal control input \nu_1^*\nu_1^*\n as the actual input.\n\n\n\n\nNote\n\n\n\n\nThe iterative solver of \nParNMPC\n relies on warm start. \nParNMPC\n provides tools to solve the very first OCP offline.\n\n\nParNMPC\n provides tools to define the controlled plant model for simulation.", 
            "title": "What is ParNMPC"
        }, 
        {
            "location": "/#parnmpc-a-parallel-computing-toolbox-for-nonlinear-mpc", 
            "text": "Version 1808-1 ( Github: ParNMPC ) has been released!", 
            "title": "ParNMPC : A Parallel Computing Toolbox for Nonlinear MPC"
        }, 
        {
            "location": "/#introduction", 
            "text": "ParNMPC  is a MATLAB real-time optimization toolkit for nonlinear model predictive control (NMPC). ParNMPC  can utilize multiple CPU cores to solve the optimal control problem, and thus can be very fast (the computation time is usually in the range of  \\mu \\mu s). \nThe purpose of  ParNMPC  is to provide an easy-to-use environment for NMPC problem formulation, closed-loop simulation, and deployment.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "Symbolic problem representation  Automatic parallel C/C++ code generation with OpenMP  Fast rate of convergence (up to be superlinear)  Highly parallelizable (capable of using at most N cores, N is the # of discretization steps)  High speedup ratio  MATLAB   Simulink", 
            "title": "Features"
        }, 
        {
            "location": "/#problems-supported-in-parnmpc", 
            "text": "The optimization control problem (OCP) supported in  ParNMPC  has the following form:   \\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)} \\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad  x(0) = \\bar{x}_0,\\\\ M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\  C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\  u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\  x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\  G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T].\n\\end{align}  \\begin{align}\n\\min_{x(\\cdot),\\ u(\\cdot)}&\\int^{T}_{0}L\\left(u(t),x(t),p(t)\\right)dt \\\\\n\\text{s.t.}\\quad &x(0) = \\bar{x}_0,\\\\\n&M\\left(u(t),x(t),p(t)\\right)\\dot{x}(t)=f\\left(u(t),x(t),p(t)\\right),\\quad t\\in[0,T],\\\\\n& C(u(t),x(t),p(t))=0,\\quad t\\in[0,T],\\\\\n& u_{min} \\leq u(t) \\leq u_{max},\\quad t\\in[0,T],\\\\\n& x_{min} \\leq x(t) \\leq x_{max},\\quad t\\in[0,T],\\\\\n& G_{min} \\leq G\\left(u(t),x(t),p(t)\\right) \\leq G_{max},\\quad t\\in[0,T].\n\\end{align}   Here,     Sign  Size  Description  Sign  Size  Description      u u  [uDim,1]  Input vector  L L  [1,1]  Cost function    x x  [xDim,1]  State vector  C C  [muDim,1]  Equality constraint function    p p  [pDim,1]  Given parameter vector  f f  [xDim,1]  Dynamics    T T  [1,1]  Prediction horizon  M M  [xDim,xDim]  (Optional, e.g., Lagrange model)    \\bar{x}_0 \\bar{x}_0  [xDim,1]  Current state vector  G G  [GDim,1]  Polytopic constraint function ( G G  is linear in  u u  and  x x )    u_{min} u_{min}  [uDim,1]  Lower bound of  u u  u_{max} u_{max}  [uDim,1]  Upper bound of  u u    x_{min} x_{min}  [xDim,1]  Lower bound of  x x  x_{max} x_{max}  [xDim,1]  Upper bound of  x x    G_{min} G_{min}  [GDim,1]  Lower bound of  G G  G_{max} G_{max}  [GDim,1]  Upper bound of  G G      Note   Varying dynamics, prediction horizon and references, and terminal cost function can be achieved by using the parameter  p p .", 
            "title": "Problems Supported in  ParNMPC"
        }, 
        {
            "location": "/#how-parnmpc-solves-the-ocp", 
            "text": "", 
            "title": "How ParNMPC Solves the OCP?"
        }, 
        {
            "location": "/#discretization", 
            "text": "ParNMPC   discretizes the OCP defined above into the following problem with  N N  steps:   \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad   x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\  C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\  u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\  x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\  G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}  \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i) \\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& u_{min}\\leq u_i\\leq u_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& x_{min}\\leq x_i\\leq x_{max},\\quad i\\in\\{1,\\cdots,N\\},\\\\\n& G_{min}\\leq G(u_i,x_i,p_i)\\leq G_{max},\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}   Here, the continuous-time state equation  \\dot{x}(t)=f(u(t),x(t),p(t)) \\dot{x}(t)=f(u(t),x(t),p(t))  (if  M M  is not imposed) is discretized to be  F(x_{i-1},u_i,x_i,p_i)=0 F(x_{i-1},u_i,x_i,p_i)=0 , e.g., the backward Euler's method with  F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i F(x_{i-1},u_i,x_i,p_i) = x_{i-1} + f(u_i,x_i,p_i)\\Delta\\tau - x_i , where  \\Delta\\tau=T/N \\Delta\\tau=T/N .", 
            "title": "Discretization"
        }, 
        {
            "location": "/#handling-inequality-constraints", 
            "text": "The inequality constraints are converted into logarithmic barrier functions (i.e., interior-point method).\nThe following equality-constrained problem is obtained:   \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N} L(u_i,x_i,p_i)  \\\\\n-\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N} \\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\\n\\text{s.t.}\\quad   x_0 = \\bar{x}_0,\\\\ F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\  C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}  \\begin{align}\n\\min_{X,\\ U}\\sum_{i=1}^{N}&L(u_i,x_i,p_i)  \\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{u}}\\left(\\log(u_{max(j)}-u_{i(j)})+\\log(u_{i(j)}-u_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{x}}\\left(\\log(x_{max(j)}-x_{i(j)})+\\log(x_{i(j)}-x_{min(j)})\\right)\\\\\n-\\gamma\\sum_{i=1}^{N}&\\sum_{j=1}^{n_{G}}\\left(\\log(G_{max(j)}-G_{i(j)})+\\log(G_{i(j)}-G_{min(j)})\\right)\\\\\n\\text{s.t.}\\quad & x_0 = \\bar{x}_0,\\\\\n&F(x_{i-1},u_i,x_i,p_i)=0, \\quad i\\in\\{1,\\cdots,N\\},\\\\\n& C(u_i,x_i,p_i)=0,\\quad i\\in\\{1,\\cdots,N\\}.\n\\end{align}   Here,  v_{(j)} v_{(j)}  is the  j j -th element of a variable  v v ,  G_{i(j)} G_{i(j)}  is the   j j -th element of  G(u_i,x_i,p_i) G(u_i,x_i,p_i) , and  \\gamma \\gamma  is the barrier parameter.\nFor simplicity, the same barrier parameter is used here. It can be set to be different for different constraints in  ParNMPC .", 
            "title": "Handling inequality constraints"
        }, 
        {
            "location": "/#solving-the-kkt-conditions-iteratively-in-parallel", 
            "text": "Then,  ParNMPC  derives the KKT conditions for the problem above by introducing Lagrange multipliers  \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N}  for the state equations and  \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N}  for the equality constraints.  Next, the KKT conditions are solved iteratively in parallel for a given initial state  \\bar{x}_0 \\bar{x}_0  and given parameters  \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} .\nThe NMPC controller is implemented by applying the first optimal control input  u_1^* u_1^*  as the actual input.   Note   The iterative solver of  ParNMPC  relies on warm start.  ParNMPC  provides tools to solve the very first OCP offline.  ParNMPC  provides tools to define the controlled plant model for simulation.", 
            "title": "Solving the KKT conditions iteratively in parallel"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\n\n\nClone or download \nParNMPC\n from \nGithub: ParNMPC\n.\n\n\n\n\nExtract the downloaded file.\n\n\n\n\nRequirements\n\n\nParNMPC\n supports MATLAB R2016a or later. The following tools are required:\n\n\n\n\nMATLAB Coder\n\n\nMATLAB Optimization Toolbox\n\n\nMATLAB Parallel Computing Toolbox\n\n\nMATLAB Symbolic Math Toolbox\n\n\nC/C++ compiler supporting parallel code generation\n\n\n\n\nFor compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check \nSupported and Compatible Compilers\n for details.\n\n\n\n\n\n\nWarning\n\n\nParNMPC\n may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds.\nCheck \nsym bug report\n for details.\n\n\n\n\n\n\n\n\nDirectory Layout\n\n\nThe directory layout of \nParNMPC\n is as follows:\n\n\n.\n\u251c\u2500 ParNMPC/                  \n# Toolkit\n\n\u2502  \u251c\u2500 ...\n\u251c\u2500 docs/                     \n# Homepage\n\n\u2502  \u251c\u2500 ...                    \n\u251c\u2500 SemiActiveDamper/         \n# Example of controlling a semi-active damper\n\n\u2502  \u251c\u2500 NMPC_Problem_Formulation.m    \n# NMPC formulation and initialization\n\n\u2502  \u251c\u2500 Simu_Matlab.m                 \n# Closed-loop simulation in MATLAB\n\n\u2502  \u251c\u2500 Simu_Simulink.slx             \n# Closed-loop simulation in Simulink\n\n\u2502  \u251c\u2500 Simu_Simulink_Setup.m         \n# Setup for the Simulink simulation\n\n\u2502  \u251c\u2500 Timer.m                       \n# Your own timer function\n\n\u2502  \u251c\u2500 GEN_initData.mat              \n# Initial guess\n\n\u251c\u2500 DoubleInvertedPendulum/   \n# Example of swinging up an inverted pendulum\n\n\u2502  \u251c\u2500 ...                    \n\u2514\u2500 Quadrotor/                \n# Example of controlling a quadrotor\n\n\u2502  \u251c\u2500 ...      \n\u2514\u2500 Vehicle/                  \n# Example of controlling a vehicle\n\n\u2502  \u251c\u2500 ...                            \n\n\n\n\nGetting Started\n\n\nThis section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example.\n\n\n\n\n\n\nRun the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler:\n\n \nmex\n \n-\nsetup\n\n\n\n\n\n\n\n\nNavigate to the \nQuadrotor/\n folder.\n\n \ncd\n  \nQuadrotor\n/\n\n\n\n\n\n\n\n\nOpen \nNMPC_Problem_Formulation.m\n and run. By running this file, the following things are done:\n\n\n\n\nThe NMPC controller is defined and configured, and necessary files are automatically generated to the \n./funcgen/\n and \n./codegen/\n folders.\n\n\nThe very first OCP is solved and its solution is saved to \nGEN_initData.mat\n.\n\n\nThe controlled plant for simulation is defined and auto-generated.\n\n\n\n\n\n\n\n\nOpen \nSimu_Simulink_Setup.m\n and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file.\n\n\n\n\n\n\nOpen \nSimu_Simulink.slx\n and run. \nSimu_Simulink.slx\n calls the generated NMPC controller function from the DLL file.\n\n\n\n\nWarning\n\n\nRunning \nSimu_Matlab.m\n directly is not in parallel.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Clone or download  ParNMPC  from  Github: ParNMPC .   Extract the downloaded file.   Requirements  ParNMPC  supports MATLAB R2016a or later. The following tools are required:   MATLAB Coder  MATLAB Optimization Toolbox  MATLAB Parallel Computing Toolbox  MATLAB Symbolic Math Toolbox  C/C++ compiler supporting parallel code generation   For compilers that do not support OpenMP, code generation will treat parallel computing as serial computing. Check  Supported and Compatible Compilers  for details.    Warning  ParNMPC  may not work properly on MATLAB R2017b and R2018a because of the bug that exists in certain Windows 10 builds.\nCheck  sym bug report  for details.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#directory-layout", 
            "text": "The directory layout of  ParNMPC  is as follows:  .\n\u251c\u2500 ParNMPC/                   # Toolkit \n\u2502  \u251c\u2500 ...\n\u251c\u2500 docs/                      # Homepage \n\u2502  \u251c\u2500 ...                    \n\u251c\u2500 SemiActiveDamper/          # Example of controlling a semi-active damper \n\u2502  \u251c\u2500 NMPC_Problem_Formulation.m     # NMPC formulation and initialization \n\u2502  \u251c\u2500 Simu_Matlab.m                  # Closed-loop simulation in MATLAB \n\u2502  \u251c\u2500 Simu_Simulink.slx              # Closed-loop simulation in Simulink \n\u2502  \u251c\u2500 Simu_Simulink_Setup.m          # Setup for the Simulink simulation \n\u2502  \u251c\u2500 Timer.m                        # Your own timer function \n\u2502  \u251c\u2500 GEN_initData.mat               # Initial guess \n\u251c\u2500 DoubleInvertedPendulum/    # Example of swinging up an inverted pendulum \n\u2502  \u251c\u2500 ...                    \n\u2514\u2500 Quadrotor/                 # Example of controlling a quadrotor \n\u2502  \u251c\u2500 ...      \n\u2514\u2500 Vehicle/                   # Example of controlling a vehicle \n\u2502  \u251c\u2500 ...", 
            "title": "Directory Layout"
        }, 
        {
            "location": "/installation/#getting-started", 
            "text": "This section shows how to do the closed-loop simulation in Simulink using MATLAB R2016a and Microsoft Visual C++ 2015 Professional as an example.    Run the following MATLAB command and select the Microsoft Visual C++ 2015 Professional (C) compiler:   mex   - setup     Navigate to the  Quadrotor/  folder.   cd    Quadrotor /     Open  NMPC_Problem_Formulation.m  and run. By running this file, the following things are done:   The NMPC controller is defined and configured, and necessary files are automatically generated to the  ./funcgen/  and  ./codegen/  folders.  The very first OCP is solved and its solution is saved to  GEN_initData.mat .  The controlled plant for simulation is defined and auto-generated.     Open  Simu_Simulink_Setup.m  and run. By doing this, the NMPC controller is generated into C codes and compilied into a DLL file.    Open  Simu_Simulink.slx  and run.  Simu_Simulink.slx  calls the generated NMPC controller function from the DLL file.   Warning  Running  Simu_Matlab.m  directly is not in parallel.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/interfaces/", 
            "text": "Interfaces\n\n\nClasses\n\n\n\n\n\n\n\n\nClass name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nFormulate an OCP\n\n\n\n\n\n\nNMPCSolver\n\n\nConfigurate the NMPC solver\n\n\n\n\n\n\nOCPSolver\n\n\nSolve the very first OCP offline\n\n\n\n\n\n\nDynamicSystem\n\n\nConstruct a dynamic system\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nFormulate an OCP.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndim\n\n\nstructure.{lambda,mu,u,x,p}\n, dimensions of lambda, mu, u, x, p.\n\n\n\n\n\n\nlambda\n\n\nsymbolic vector [xDim,1]\n, multiplier vector.\n\n\n\n\n\n\nmu\n\n\nsymbolic vector [muDim,1]\n, multiplier vector.\n\n\n\n\n\n\nu\n\n\nsymbolic vector [uDim,1]\n, input vector.\n\n\n\n\n\n\nx\n\n\nsymbolic vector [xDim,1]\n, state vector.\n\n\n\n\n\n\np\n\n\nsymbolic vector [pDim,1]\n, parameter vector.\n\n\n\n\n\n\nf\n\n\nsymbolic expression [xDim,1]\n, function f.\n\n\n\n\n\n\nM\n\n\nsymbolic expression [xDim,xDim]\n, matrix M .\n\n\n\n\n\n\nL\n\n\nsymbolic expression [1,1]\n, function L.\n\n\n\n\n\n\nC\n\n\nsymbolic expression [muDim,1]\n, function C.\n\n\n\n\n\n\nG\n\n\nsymbolic expression [GDim,1]\n, function G.\n\n\n\n\n\n\nN\n\n\npositive integer [1,1]\n, number of discretization grids N.\n\n\n\n\n\n\nT\n\n\npositive [1,1]\n, prediction horizon T.\n\n\n\n\n\n\ndeltaTau\n\n\npositive [1,1]\n, discretization size (T/N).\n\n\n\n\n\n\ndiscretizationMethod\n\n\nstring\n, discretization method.\n\n\n\n\n\n\nisMEnabled\n\n\nbool\n, whether the M matrix is enabled.\n\n\n\n\n\n\nuMax\n\n\nstructure.{value,barrierParameter}\n, upper bound of u.\n\n\n\n\n\n\nuMin\n\n\nstructure.{value,barrierParameter}\n, lower bound of u.\n\n\n\n\n\n\nxMax\n\n\nstructure.{value,barrierParameter}\n, upper bound of x.\n\n\n\n\n\n\nxMin\n\n\nstructure.{value,barrierParameter}\n, lower bound of x.\n\n\n\n\n\n\nGMax\n\n\nstructure.{value,barrierParameter}\n, upper bound of G.\n\n\n\n\n\n\nGMin\n\n\nstructure.{value,barrierParameter}\n, lower bound of G.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOptimalControlProblem\n\n\nConstructor.\nInput:\nmuDim\n: \nnonnegtive integer [1,1]\n, dimension of mu.\nuDim\n: \npositive integer [1,1]\n, dimension of u.\nxDim\n: \npositive integer [1,1]\n, dimension of x.\npDim\n: \nnonnegtive integer [1,1]\n, dimension of p.\nT\n: \npositive [1,1]\n, prediction horizon.\nN\n: \npositive integer [1,1]\n, number of discretization grids.\nOutput:\nOptimalControlProblem\n\n\n\n\n\n\nsetf\n\n\nSet f.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetM\n\n\nSet M.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetStateName\n\n\nGive names to all or part of the states.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetInputName\n\n\nGive names to all or part of the inputs.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetParameterName\n\n\nGive names to all or part of the parameters.\nInherit from \nDynamicSystem\n\n\n\n\n\n\nsetL\n\n\nSet L.\nInput:\nL\n: \nsymbolic expression [1,1]\n, function L.\nOutput: none.\n\n\n\n\n\n\nsetC\n\n\nSet C.\nInput:\nC\n: \nsymbolic expression [muDim,1]\n, function C.\nOutput: none.\n\n\n\n\n\n\nsetT\n\n\nSet T.\nInput:\nT\n: \nsymbolic variable/double [1,1]\n, must be included in \np\n if it is a symbolic variable.\nOutput: none.\n\n\n\n\n\n\nsetG\n\n\nSet G.\nInput:\nC\n: \nsymbolic expression [GDim,1]\n, function G.\nOutput: none.\n\n\n\n\n\n\nsetUpperBound\n\n\nSet the upper bound of u, x, or G.\nInput:\nfield\n: \nstring\n, \nx\n, \nu\n, or \nG\n.\nboundValue\n: \n[~Dim,1]\n, bound value, i.e., \nx_{max}\nx_{max}\n, \nu_{max}\nu_{max}\n, or \nG_{max}\nG_{max}\n.\nbarrierParameter\n: \npositive [~Dim,1]\n, barrier parameter of the logarithmic function.\n\n\n\n\n\n\nsetLowerBound\n\n\nSet the lower bound of u, x, or G.\nInput:\nfield\n: \nstring\n, \nx\n, \nu\n, or \nG\n.\nboundValue\n: \n[~Dim,1]\n, bound value, i.e., \nx_{min}\nx_{min}\n, \nu_{min}\nu_{min}\n, or \nG_{min}\nG_{min}\n.\nbarrierParameter\n: \npositive [~Dim,1]\n, barrier parameter of the logarithmic function.\n\n\n\n\n\n\nsetDiscretizationMethod\n\n\nSet the discretization method.\nInput:\nmethod\n: \nstring\n, \nEuler\n or \nRK4\n, discretization method.\nOutput: none\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nNMPCSolver\n\n\nConfigurate the NMPC solver.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCP\n\n\nOptimalControlProblem\n, OptimalControlProblem object.\n\n\n\n\n\n\nHessianApproximation\n\n\nstring\n, Hessian approximation method.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNMPCSolver\n\n\nConstructor.\nInput:\nOCP\n: \nOptimalControlProblem\n, OptimalControlProblem object.\nOutput:\nNMPCSolver\n\n\n\n\n\n\nsetHessianApproximation\n\n\nSet the Hessian approximation method.\nInput:\nmethod\n: \nstring\n, \nNewton\n, \nGaussNewton\n, or \nGaussNewtonLC\n, Hessian approximation method.\nOutput: none\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nOCPSolver\n\n\nSolve the very first OCP offline.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCP\n\n\nOptimalControlProblem\n, OptimalControlProblem object.\n\n\n\n\n\n\nNMPCSolver\n\n\nNMPCSolver\n, NMPCSolver object.\n\n\n\n\n\n\nx0\n\n\n[xDim,1]\n, initial state.\n\n\n\n\n\n\nlambda\n\n\n[xDim,N]\n, multipliers.\n\n\n\n\n\n\nmu\n\n\n[muDim,N]\n, multipliers.\n\n\n\n\n\n\nu\n\n\n[uDim,N]\n, inputs.\n\n\n\n\n\n\nx\n\n\n[xDim,N]\n, states.\n\n\n\n\n\n\np\n\n\n[pDim,N]\n, given parameters.\n\n\n\n\n\n\nLAMBDA\n\n\n[xDim,xDim,N]\n, dependent variable LAMBDA.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nOCPSolver\n\n\nConstructor.\nInput:\nOCP\n: \nOptimalControlProblem\n, OptimalControlProblem object.\nNMPCSolver\n: \nNMPCSolver\n, NMPCSolver object.\nx0\n: \n[xDim,1]\n, initial state.\npar\n: \n[pDim,N]\n, given parameters.\nOutput:\nOCPSolver\n\n\n\n\n\n\nOCPSolve\n\n\nSolve the OCP with a providing initial guess offline.\nInput:\nlambdaInitGuess\n: \n[xDim,N]\n, initial guess of lambda.\nmuInitGuess\n: \n[muDim,N]\n, initial guess of mu.\nuInitGuess\n: \n[uDim,N]\n, initial guess of u.\nxInitGuess\n: \n[xDim,N]\n, initial guess of x.\nmethod\n: \nstring\n, \nfmincon\n or \nNMPC_Iter\n, solver.\nmaxIter\n: \n[1,1]\n, max number of iterations.\nOutput: \nlambda\n: \n[xDim,N]\n, optimal value of lambda.\nmu\n: \n[muDim,N]\n, optimal value of mu.\nu\n: \n[uDim,N]\n, optimal value of u.\nx\n: \n[xDim,N]\n, optimal value of x.\n\n\n\n\n\n\ninitFromMatFile\n\n\nInitialize from file with automatic interpolation.\nInput:\nmatFile\n: \nstring\n, file name of the mat file.\nOutput: \nlambda\n: \n[xDim,N]\n, interpolated value of lambda.\nmu\n: \n[muDim,N]\n, interpolated value of mu.\nu\n: \n[uDim,N]\n, interpolated value of u.\nx\n: \n[xDim,N]\n, interpolated value of x.\n\n\n\n\n\n\ninitFromStartEnd\n\n\nInitialize from the start and the end values by linear interpolation.\nInput:\nlambdaStart\n: \n[xDim,1]\n, start value of lambda.\nmuStart\n: \n[muDim,1]\n, start value of mu.\nuStart\n: \n[uDim,1]\n, start value of u.\nxStart\n: \n[xDim,1]\n, start value of x.\nlambdaEnd\n: \n[xDim,1]\n, end value of lambda.\nmuEnd\n: \n[muDim,1]\n, end value of mu.\nuEnd\n: \n[uDim,1]\n, end value of u.\nxEnd\n: \n[xDim,1]\n, end value of x.\nOutput: \nlambda\n: \n[xDim,N]\n, interpolated value of lambda.\nmu\n: \n[muDim,N]\n, interpolated value of mu.\nu\n: \n[uDim,N]\n, interpolated value of u.\nx\n: \n[xDim,N]\n, interpolated value of x.\n\n\n\n\n\n\ngetLAMBDA\n\n\nGet the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p.\nInput:\nx0\n: \n[xDim,1]\n, initial state.\nlambda\n: \n[xDim,N]\n, lambda.\nmu\n: \n[muDim,N]\n, mu.\nu\n: \n[uDim,N]\n, u.\nx\n: \n[xDim,N]\n, x.\np\n: \n[pDim,N]\n, p.\nOutput:\nLAMBDA\n: \n[xDim,xDim,N]\n.\n\n\n\n\n\n\ngetCost\n\n\nGet the cost function from the given u, x, p.\nInput:\nu\n: \n[uDim,N]\n, u.\nx\n: \n[xDim,N]\n, x.\np\n: \n[pDim,N]\n, p.\nOutput:\ncost\n: \n[1,1]\n.\n\n\n\n\n\n\n\n\nDynamicSystem\n\n\nConstruct a dynamic system \nM(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t))\nM(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t))\n.\n\n\n\n\nExample\n\n\n./NMPC_Problem_Formulation.m\n\n\n\n\n\n\n\n\n\n\nProperties\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndim\n\n\nstructure.{u;x;p}\n, dimensions of u, x, p.\n\n\n\n\n\n\nu\n\n\nsymbolic vector [uDim,1]\n, input vector.\n\n\n\n\n\n\nx\n\n\nsymbolic vector [xDim,1]\n, state vector.\n\n\n\n\n\n\np\n\n\nsymbolic vector [pDim,1]\n, parameter vector.\n\n\n\n\n\n\nf\n\n\nsymbolic expression [xDim,1]\n, function f.\n\n\n\n\n\n\nM\n\n\nsymbolic expression [xDim,xDim]\n, matrix M .\n\n\n\n\n\n\nisMEnabled\n\n\nbool\n, whether the M matrix is enabled.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDynamicSystem\n\n\nConstructor.\nInput:\nuDim\n: \n[1,1]\n, dimension of u.\nxDim\n: \n[1,1]\n, dimension of x.\npDim\n: \n[1,1]\n, dimension of p.\nOutput:\nDynamicSystem\n\n\n\n\n\n\nsetf\n\n\nSet f.\nInput:\nf\n: \nsymbolic expression [xDim,1]\n, function f.\nOutput: none.\n\n\n\n\n\n\nsetM\n\n\nSet M.\nInput:\nM\n: \nsymbolic expression [xDim,xDim]\n, M matrix.\nOutput: none.\n\n\n\n\n\n\nsetStateName\n\n\nGive names to all or part of the states.\nExample:\n[X,Y,Z] =~.setStateName({\nX\n,\nY\n,\nZ\n});\n[X,Z] =~.setStateName({\nX\n,\nZ\n},[1 3]);\n\n\n\n\n\n\nsetInputName\n\n\nGive names to all or part of the inputs.\nExample:\n[F1,F2,F3] =~.setInputName({\nF1\n,\nF2\n,\nF3\n};\n[F1,F3] =~.setInputName({\nF1\n,\nF3\n},[1 3]);\n\n\n\n\n\n\nsetParameterName\n\n\nGive names to all or part of the parameters.\nExample:\n[a,b,c] =~.setParameterName({\na\n,\nb\n,\nc\n};\n[a,c] =~.setParameterName({\na\n,\nc\n},[1 3]);\n\n\n\n\n\n\ncodeGen\n\n\nGenerate necessary files.\nInput: none.\nOutput: none.\n\n\n\n\n\n\n\n\nFunctions\n\n\n\n\n\n\n\n\nFunction name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNMPC_Iter\n\n\nPerform one iteration  for solving the KKT conditions.\n\n\n\n\n\n\nNMPC_Iter_CodeGen\n\n\nGenerate code for function \nNMPC_Iter\n.\n\n\n\n\n\n\nSIM_Plant_RK4\n\n\nSimulate the dynamic system using the 4-order Runge-Kutta method.\n\n\n\n\n\n\nTimer\n\n\nSpecify your own timer function.\n\n\n\n\n\n\n\n\nNMPC_Iter\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nNMPC_Iter\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nPerform one iteration to solve the KKT conditions.\n\n\n\n\n\n\nInput\n\n\nx0\n: \n[xDim,1]\n, initial state.\nlambda\n: \n[xDim,N/DoP,DoP]\n, initial guess of lambda.\nmu\n: \n[muDim,N/DoP,DoP]\n, initial guess of mu.\nu\n: \n[uDim,N/DoP,DoP]\n, initial guess of u.\nx\n: \n[xDim,N/DoP,DoP]\n, initial guess of x.\np\n: \n[pDim,N/DoP,DoP]\n, given parameters.\nLAMBDA\n: \n[xDim,xDim,N/DoP,DoP]\n, initial guess of LAMBDA.\n\n\n\n\n\n\nOutput\n\n\nlambda\n: \n[xDim,N/DoP,DoP]\n.\nmu\n: \n[muDim,N/DoP,DoP]\n.\nu\n: \n[uDim,N/DoP,DoP]\n.\nx\n: \n[xDim,N/DoP,DoP]\n.\nLAMBDA\n: \n[xDim,xDim,N/DoP,DoP]\n.\ncost\n: \n[1,1]\n, evaluation of the cost function after iteration.\nerror\n: \n[1,1]\n, Euclidean norm of the KKT conditions.\ntimeElapsed\n: \n[1,1]\n, computation time in second.\n\n\n\n\n\n\n\n\nNMPC_Iter_CodeGen\n\n\n\n\nExample\n\n\n./Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nNMPC_Iter_CodeGen\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nGenerate code for function \nNMPC_Iter\n.\n\n\n\n\n\n\nInput\n\n\ntarget\n: \nstring\n, \nmex\n, \ndll\n, or \nmex\n, target.\ntargetLang\n: \nstring\n, \nC\n or '\nC++\n', target language.\nargs\n: \ncell\n, arguments applied to \nNMPC_Iter\n.\n\n\n\n\n\n\nOutput\n\n\nNone\n\n\n\n\n\n\n\n\nSIM_Plant_RK4\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nSIM_Plant_RK4\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSimulate the dynamic system using the 4-order Runge-Kutta method.\n\n\n\n\n\n\nInput\n\n\nu\n: \n[uDim,1]\n, inputs applied to the plant.\nx\n: \n[xDim,1]\n, current state of the plant.\np\n: \n[pDim,1]\n, given parameters.\nTs\n: \npositive [1,1]\n, sampling interval.\n\n\n\n\n\n\nOutput\n\n\nxNext\n: \n[xDim,1]\n, next state of the plant.\n\n\n\n\n\n\n\n\nTimer\n\n\n\n\nExample\n\n\n./Timer.m\n\n\n\n\n\n\n\n\n\n\nFunction name\n\n\nTimer\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nMeasure the current time.\n\n\n\n\n\n\nInput\n\n\nNone\n\n\n\n\n\n\nOutput\n\n\nt\n: \n[1,1]\n, current time.\n\n\n\n\n\n\nStatement\n\n\nCreate \nTimer.m\n in the working directory to specify your own timer function.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/interfaces/#interfaces", 
            "text": "", 
            "title": "Interfaces"
        }, 
        {
            "location": "/interfaces/#classes", 
            "text": "Class name  Description      OptimalControlProblem  Formulate an OCP    NMPCSolver  Configurate the NMPC solver    OCPSolver  Solve the very first OCP offline    DynamicSystem  Construct a dynamic system", 
            "title": "Classes"
        }, 
        {
            "location": "/interfaces/#optimalcontrolproblem", 
            "text": "Formulate an OCP.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      dim  structure.{lambda,mu,u,x,p} , dimensions of lambda, mu, u, x, p.    lambda  symbolic vector [xDim,1] , multiplier vector.    mu  symbolic vector [muDim,1] , multiplier vector.    u  symbolic vector [uDim,1] , input vector.    x  symbolic vector [xDim,1] , state vector.    p  symbolic vector [pDim,1] , parameter vector.    f  symbolic expression [xDim,1] , function f.    M  symbolic expression [xDim,xDim] , matrix M .    L  symbolic expression [1,1] , function L.    C  symbolic expression [muDim,1] , function C.    G  symbolic expression [GDim,1] , function G.    N  positive integer [1,1] , number of discretization grids N.    T  positive [1,1] , prediction horizon T.    deltaTau  positive [1,1] , discretization size (T/N).    discretizationMethod  string , discretization method.    isMEnabled  bool , whether the M matrix is enabled.    uMax  structure.{value,barrierParameter} , upper bound of u.    uMin  structure.{value,barrierParameter} , lower bound of u.    xMax  structure.{value,barrierParameter} , upper bound of x.    xMin  structure.{value,barrierParameter} , lower bound of x.    GMax  structure.{value,barrierParameter} , upper bound of G.    GMin  structure.{value,barrierParameter} , lower bound of G.        Functions  Description      OptimalControlProblem  Constructor. Input: muDim :  nonnegtive integer [1,1] , dimension of mu. uDim :  positive integer [1,1] , dimension of u. xDim :  positive integer [1,1] , dimension of x. pDim :  nonnegtive integer [1,1] , dimension of p. T :  positive [1,1] , prediction horizon. N :  positive integer [1,1] , number of discretization grids. Output: OptimalControlProblem    setf  Set f. Inherit from  DynamicSystem    setM  Set M. Inherit from  DynamicSystem    setStateName  Give names to all or part of the states. Inherit from  DynamicSystem    setInputName  Give names to all or part of the inputs. Inherit from  DynamicSystem    setParameterName  Give names to all or part of the parameters. Inherit from  DynamicSystem    setL  Set L. Input: L :  symbolic expression [1,1] , function L. Output: none.    setC  Set C. Input: C :  symbolic expression [muDim,1] , function C. Output: none.    setT  Set T. Input: T :  symbolic variable/double [1,1] , must be included in  p  if it is a symbolic variable. Output: none.    setG  Set G. Input: C :  symbolic expression [GDim,1] , function G. Output: none.    setUpperBound  Set the upper bound of u, x, or G. Input: field :  string ,  x ,  u , or  G . boundValue :  [~Dim,1] , bound value, i.e.,  x_{max} x_{max} ,  u_{max} u_{max} , or  G_{max} G_{max} . barrierParameter :  positive [~Dim,1] , barrier parameter of the logarithmic function.    setLowerBound  Set the lower bound of u, x, or G. Input: field :  string ,  x ,  u , or  G . boundValue :  [~Dim,1] , bound value, i.e.,  x_{min} x_{min} ,  u_{min} u_{min} , or  G_{min} G_{min} . barrierParameter :  positive [~Dim,1] , barrier parameter of the logarithmic function.    setDiscretizationMethod  Set the discretization method. Input: method :  string ,  Euler  or  RK4 , discretization method. Output: none    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "OptimalControlProblem"
        }, 
        {
            "location": "/interfaces/#nmpcsolver", 
            "text": "Configurate the NMPC solver.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      OCP  OptimalControlProblem , OptimalControlProblem object.    HessianApproximation  string , Hessian approximation method.        Functions  Description      NMPCSolver  Constructor. Input: OCP :  OptimalControlProblem , OptimalControlProblem object. Output: NMPCSolver    setHessianApproximation  Set the Hessian approximation method. Input: method :  string ,  Newton ,  GaussNewton , or  GaussNewtonLC , Hessian approximation method. Output: none    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "NMPCSolver"
        }, 
        {
            "location": "/interfaces/#ocpsolver", 
            "text": "Solve the very first OCP offline.   Example  ./NMPC_Problem_Formulation.m      Properties  Description      OCP  OptimalControlProblem , OptimalControlProblem object.    NMPCSolver  NMPCSolver , NMPCSolver object.    x0  [xDim,1] , initial state.    lambda  [xDim,N] , multipliers.    mu  [muDim,N] , multipliers.    u  [uDim,N] , inputs.    x  [xDim,N] , states.    p  [pDim,N] , given parameters.    LAMBDA  [xDim,xDim,N] , dependent variable LAMBDA.        Functions  Description      OCPSolver  Constructor. Input: OCP :  OptimalControlProblem , OptimalControlProblem object. NMPCSolver :  NMPCSolver , NMPCSolver object. x0 :  [xDim,1] , initial state. par :  [pDim,N] , given parameters. Output: OCPSolver    OCPSolve  Solve the OCP with a providing initial guess offline. Input: lambdaInitGuess :  [xDim,N] , initial guess of lambda. muInitGuess :  [muDim,N] , initial guess of mu. uInitGuess :  [uDim,N] , initial guess of u. xInitGuess :  [xDim,N] , initial guess of x. method :  string ,  fmincon  or  NMPC_Iter , solver. maxIter :  [1,1] , max number of iterations. Output:  lambda :  [xDim,N] , optimal value of lambda. mu :  [muDim,N] , optimal value of mu. u :  [uDim,N] , optimal value of u. x :  [xDim,N] , optimal value of x.    initFromMatFile  Initialize from file with automatic interpolation. Input: matFile :  string , file name of the mat file. Output:  lambda :  [xDim,N] , interpolated value of lambda. mu :  [muDim,N] , interpolated value of mu. u :  [uDim,N] , interpolated value of u. x :  [xDim,N] , interpolated value of x.    initFromStartEnd  Initialize from the start and the end values by linear interpolation. Input: lambdaStart :  [xDim,1] , start value of lambda. muStart :  [muDim,1] , start value of mu. uStart :  [uDim,1] , start value of u. xStart :  [xDim,1] , start value of x. lambdaEnd :  [xDim,1] , end value of lambda. muEnd :  [muDim,1] , end value of mu. uEnd :  [uDim,1] , end value of u. xEnd :  [xDim,1] , end value of x. Output:  lambda :  [xDim,N] , interpolated value of lambda. mu :  [muDim,N] , interpolated value of mu. u :  [uDim,N] , interpolated value of u. x :  [xDim,N] , interpolated value of x.    getLAMBDA  Get the dependent variable LAMBDA from the given x0, lambda, mu, u, x, p. Input: x0 :  [xDim,1] , initial state. lambda :  [xDim,N] , lambda. mu :  [muDim,N] , mu. u :  [uDim,N] , u. x :  [xDim,N] , x. p :  [pDim,N] , p. Output: LAMBDA :  [xDim,xDim,N] .    getCost  Get the cost function from the given u, x, p. Input: u :  [uDim,N] , u. x :  [xDim,N] , x. p :  [pDim,N] , p. Output: cost :  [1,1] .", 
            "title": "OCPSolver"
        }, 
        {
            "location": "/interfaces/#dynamicsystem", 
            "text": "Construct a dynamic system  M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) M(u(t),x(t),p(t))\\dot{x}=f(u(t),x(t),p(t)) .   Example  ./NMPC_Problem_Formulation.m      Properties  Description      dim  structure.{u;x;p} , dimensions of u, x, p.    u  symbolic vector [uDim,1] , input vector.    x  symbolic vector [xDim,1] , state vector.    p  symbolic vector [pDim,1] , parameter vector.    f  symbolic expression [xDim,1] , function f.    M  symbolic expression [xDim,xDim] , matrix M .    isMEnabled  bool , whether the M matrix is enabled.        Functions  Description      DynamicSystem  Constructor. Input: uDim :  [1,1] , dimension of u. xDim :  [1,1] , dimension of x. pDim :  [1,1] , dimension of p. Output: DynamicSystem    setf  Set f. Input: f :  symbolic expression [xDim,1] , function f. Output: none.    setM  Set M. Input: M :  symbolic expression [xDim,xDim] , M matrix. Output: none.    setStateName  Give names to all or part of the states. Example: [X,Y,Z] =~.setStateName({ X , Y , Z }); [X,Z] =~.setStateName({ X , Z },[1 3]);    setInputName  Give names to all or part of the inputs. Example: [F1,F2,F3] =~.setInputName({ F1 , F2 , F3 }; [F1,F3] =~.setInputName({ F1 , F3 },[1 3]);    setParameterName  Give names to all or part of the parameters. Example: [a,b,c] =~.setParameterName({ a , b , c }; [a,c] =~.setParameterName({ a , c },[1 3]);    codeGen  Generate necessary files. Input: none. Output: none.", 
            "title": "DynamicSystem"
        }, 
        {
            "location": "/interfaces/#functions", 
            "text": "Function name  Description      NMPC_Iter  Perform one iteration  for solving the KKT conditions.    NMPC_Iter_CodeGen  Generate code for function  NMPC_Iter .    SIM_Plant_RK4  Simulate the dynamic system using the 4-order Runge-Kutta method.    Timer  Specify your own timer function.", 
            "title": "Functions"
        }, 
        {
            "location": "/interfaces/#nmpc_iter", 
            "text": "Example  ./Simu_Matlab.m      Function name  NMPC_Iter      Description  Perform one iteration to solve the KKT conditions.    Input  x0 :  [xDim,1] , initial state. lambda :  [xDim,N/DoP,DoP] , initial guess of lambda. mu :  [muDim,N/DoP,DoP] , initial guess of mu. u :  [uDim,N/DoP,DoP] , initial guess of u. x :  [xDim,N/DoP,DoP] , initial guess of x. p :  [pDim,N/DoP,DoP] , given parameters. LAMBDA :  [xDim,xDim,N/DoP,DoP] , initial guess of LAMBDA.    Output  lambda :  [xDim,N/DoP,DoP] . mu :  [muDim,N/DoP,DoP] . u :  [uDim,N/DoP,DoP] . x :  [xDim,N/DoP,DoP] . LAMBDA :  [xDim,xDim,N/DoP,DoP] . cost :  [1,1] , evaluation of the cost function after iteration. error :  [1,1] , Euclidean norm of the KKT conditions. timeElapsed :  [1,1] , computation time in second.", 
            "title": "NMPC_Iter"
        }, 
        {
            "location": "/interfaces/#nmpc_iter_codegen", 
            "text": "Example  ./Simu_Simulink_Setup.m      Function name  NMPC_Iter_CodeGen      Description  Generate code for function  NMPC_Iter .    Input  target :  string ,  mex ,  dll , or  mex , target. targetLang :  string ,  C  or ' C++ ', target language. args :  cell , arguments applied to  NMPC_Iter .    Output  None", 
            "title": "NMPC_Iter_CodeGen"
        }, 
        {
            "location": "/interfaces/#sim_plant_rk4", 
            "text": "Example  ./Simu_Matlab.m      Function name  SIM_Plant_RK4      Description  Simulate the dynamic system using the 4-order Runge-Kutta method.    Input  u :  [uDim,1] , inputs applied to the plant. x :  [xDim,1] , current state of the plant. p :  [pDim,1] , given parameters. Ts :  positive [1,1] , sampling interval.    Output  xNext :  [xDim,1] , next state of the plant.", 
            "title": "SIM_Plant_RK4"
        }, 
        {
            "location": "/interfaces/#timer", 
            "text": "Example  ./Timer.m      Function name  Timer      Description  Measure the current time.    Input  None    Output  t :  [1,1] , current time.    Statement  Create  Timer.m  in the working directory to specify your own timer function.", 
            "title": "Timer"
        }, 
        {
            "location": "/workflow/", 
            "text": "Workflow of ParNMPC\n\n\nPreparation\n\n\n\n\nChoose a compiler that supports code generation with OpenMP by \nmex -setup\n.\n\n\nEdit \nTimer.m\n to specify your own timer function.\n\n\n\n\nNMPC Problem Formulation \n\n\n\n\nExample\n\n\n./NMPC_Problem_Definition.m\n\n\n\n\n\n\n\n\nFormulate an OCP using Class \nOptimalControlProblem\n\n\n% Create an OptimalControlProblem object\n\n\nOCP\n \n=\n \nOptimalControlProblem\n(\nmuDim\n,\n... % constraints dim\n\n                            \nuDim\n,\n...  % inputs dim\n\n                            \nxDim\n,\n...  % states dim\n\n                            \npDim\n,\n...  % parameters dim (position reference)\n\n                            \nT\n,\n...     % prediction horizon\n\n                            \nN\n);\n       \n% num of discritization grids\n\n\n\n% Give names to x, u, p (optional)                          \n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetStateName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetInputName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nOCP\n.\nsetParameterName\n(\n~\n);\n\n\n\n% Reset the prediction horizon T \n\n\n% (optional for variable horizon or nonuniform discretization)\n\n\nOCP\n.\nsetT\n(\n~\n);\n\n\n\n% Set the dynamic function f\n\n\nOCP\n.\nsetf\n(\n~\n);\n\n\n\n% Set the matrix M (optional for, e.g., Lagrange model)\n\n\nOCP\n.\nsetM\n(\n~\n);\n\n\n\n% Set the equality constraint function C (optional)\n\n\nOCP\n.\nsetC\n(\n~\n);\n\n\n\n% Set the cost function L\n\n\nOCP\n.\nsetL\n(\n~\n);\n\n\n\n% Set the bound constraints (optional)\n\n\nOCP\n.\nsetUpperBound\n(\nu\n,\n~\n);\n\n\nOCP\n.\nsetLowerBound\n(\nu\n,\n~\n);\n\n\nOCP\n.\nsetUpperBound\n(\nx\n,\n~\n);\n\n\nOCP\n.\nsetLowerBound\n(\nx\n,\n~\n);\n\n\n\n% Set the polytopic constraint G (optional)\n\n\nOCP\n.\nsetG\n(\n~\n);\n\n\nOCP\n.\nsetUpperBound\n(\nG\n,\n~\n);\n\n\nOCP\n.\nsetLowerBound\n(\nG\n,\n~\n);\n\n\n\n% Generate necessary files\n\n\nOCP\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nConfigrate the solver using Class \nNMPCSolver\n\n\n% Create a NMPCSolver object\n\n\nnmpcSolver\n \n=\n \nNMPCSolver\n(\nOCP\n);\n\n\n\n% Configurate the Hessian approximation method\n\n\nnmpcSolver\n.\nsetHessianApproximation\n(\n~\n);\n\n\n\n% Generate necessary files\n\n\nnmpcSolver\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nSolve the very first OCP for a given initial state and given parameters using Class \nOCPSolver\n\n\n% Set the initial state     \n\n\nx0\n \n=\n \n[\n~\n];\n\n\n\n% Set the parameters        \n\n\npar\n \n=\n \n[\n~\n];\n\n\n\n% Create an OCPSolver object\n\n\nocpSolver\n \n=\n \nOCPSolver\n(\nOCP\n,\nnmpcSolver\n,\nx0\n,\npar\n);\n\n\n\n% Choose one of the following methods to provide an initial guess:\n\n\n% 1. init guess by input\n\n\nlambdaInitGuess\n \n=\n \n[\n~\n];\n\n\nmuInitGuess\n     \n=\n \n[\n~\n];\n\n\nuInitGuess\n      \n=\n \n[\n~\n];\n\n\nxInitGuess\n      \n=\n \n[\n~\n];\n\n\n% 2. init guess by interpolation\n\n\n[\nlambdaInitGuess\n,\nmuInitGuess\n,\nuInitGuess\n,\nxInitGuess\n]\n \n=\n \n...\n\n    \nocpSolver\n.\ninitFromStartEnd\n(\n~\n);\n\n\n% 3. init guess from file\n\n\n[\nlambdaInitGuess\n,\nmuInitGuess\n,\nuInitGuess\n,\nxInitGuess\n]\n \n=\n \n...\n\n                        \nocpSolver\n.\ninitFromMatFile\n(\n~\n);\n\n\n\n% Solve the OCP                     \n\n\n[\nlambda\n,\nmu\n,\nu\n,\nx\n]\n \n=\n \nocpSolver\n.\nOCPSolve\n(\nlambdaInitGuess\n,\n...\n\n                                     \nmuInitGuess\n,\n...\n\n                                     \nuInitGuess\n,\n...\n\n                                     \nxInitGuess\n,\n...\n\n                                     \nmethod\n...\n\n                                     \nmaxIter\n);\n\n\n\n% Get the dependent variable LAMBDA\n\n\nLAMBDA\n \n=\n \nocpSolver\n.\ngetLAMBDA\n(\nx0\n,\nlambda\n,\nmu\n,\nu\n,\nx\n,\npar\n);\n\n\n\n% Check the cost % (optional)\n\n\ncost\n \n=\n \nocpSolver\n.\ngetCost\n(\nu\n,\nx\n,\npar\n);\n \n\n\n% Save to file for further use\n\n\nsave\n \nGEN_initData\n.\nmat\n  \n...\n\n     \nx0\n \nlambda\n \nmu\n \nu\n \nx\n \npar\n \nLAMBDA\n \n~\n\n\n\n\n\n\n\n\nDefine the controlled plant using Class \nDynamicSystem\n (optional for simulation)\n\n% Create a DynamicSystem object\n\n\nplant\n \n=\n \nDynamicSystem\n(\nuDim\n,\nxDim\n,\npDim\n);\n\n\n\n% Give names to x, u, p (optional)\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetStateName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetInputName\n(\n~\n);\n\n\n[\n~\n]\n \n=\n \nplant\n.\nsetParameterName\n(\n~\n);\n\n\n\n% Set the dynamic function f\n\n\nplant\n.\nsetf\n(\n~\n);\n\n\n\n% Set the matrix M (optional for, e.g., Lagrange model)\n\n\nplant\n.\nsetM\n(\n~\n);\n\n\n\n% Generate necessary files\n\n\nplant\n.\ncodeGen\n();\n\n\n\n\n\n\n\n\nConfiguration Table:\n\n\n\n\n\n\n\n\n\n\nConfigurable discretization method\n\n\nConfigurable Hessian approximation method\n\n\n\n\n\n\n\n\n\n\nM\n enabled\n\n\nEuler\n\n\nGaussNewton\n\n\n\n\n\n\nM\n disabled\n\n\nEuler\n, \nRK4\n\n\nNewton\n, \nGaussNewton\n when \nEuler\n;\nGaussNewton\n when \nRK4\n;\n\n\n\n\n\n\n\n\nCode Generation and Deployment\n\n\nMATLAB\n\n\nHere, assume your closed-loop simulation is performed in \nSimu_Matlab.m\n.\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\n./Simu_Matlab_Codegen.m\n\n\n\n\n\n\n\n\nDeclare global variables as constants:\n\nglobal\n \ndiscretizationMethod\n \nisMEnabled\n \n...\n\n       \nuMin\n \nuMax\n \nxMin\n \nxMax\n \nGMax\n \nGMin\n \n...\n\n       \nveryBigNum\n\n\n\nglobalVariable\n \n=\n \n{\ndiscretizationMethod\n,\ncoder\n.\nConstant\n(\ndiscretizationMethod\n),\n...\n\n                  \nisMEnabled\n,\ncoder\n.\nConstant\n(\nisMEnabled\n),\n...\n\n                  \nuMax\n,\ncoder\n.\nConstant\n(\nuMax\n),\n...\n\n                  \nuMin\n,\ncoder\n.\nConstant\n(\nuMin\n),\n...\n\n                  \nxMax\n,\ncoder\n.\nConstant\n(\nxMax\n),\n...\n\n                  \nxMin\n,\ncoder\n.\nConstant\n(\nxMin\n),\n...\n\n                  \nGMax\n,\ncoder\n.\nConstant\n(\nGMax\n),\n...\n\n                  \nGMin\n,\ncoder\n.\nConstant\n(\nGMin\n),\n...\n\n                  \nveryBigNum\n,\ncoder\n.\nConstant\n(\nveryBigNum\n)};\n\n\n\n\n\n\n\n\nGenerate code using \ncodegen\n:\n\ncodegen\n \n-\nconfig\n:\nlib\n \nSimu_Matlab\n \n-\nglobals\n \nglobalVariable\n \n\n\nC code will be automatically generated to \n./codegen/lib/Simu_Matlab\n.\n\n\n\n\n\n\nDeployment in Visual Studio\n\n\n\n\n\n\nCreate an empty Win32 Console Application project.\n\n\n\n\n\n\nChange to Release x64 mode.\n\n\n\n\n\n\nAdd  \n*.h\n and \n*.c\n files in \n.\\codegen\\lib\\Simu_Matlab\n to the project.\n\n\n\n\n\n\nAdd  \nmain.h\n and \nmain.c\n in \n.\\codegen\\lib\\Simu_Matlab\\examples\n to the project.\n\n\n\n\n\n\nAdd directory \n.\\codegen\\lib\\Simu_Matlab\n to \nProperties \n C/C++ \n General \n  Additional Include Directories\n.\n\n\n\n\n\n\nProperties \n C/C++ \n Language \n  Open MP Support: Yes (/openmp)\n.\n\n\n\n\n\n\nCompile and run.\n\n\n\n\n\n\nSimulink \n\n\nHere, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function \nNMPC_Iter\n directly to compute the optimal input.\n\n\nCode generation\n\n\n\n\nExample\n\n\n./Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDefine the degree of parallelism:\n\nDoP\n \n=\n \n~\n;\n \n% degree of parallism: 1 = in serial, otherwise in parallel\n\n\n\n\n\n\n\n\nSplit \n\\{\\lambda_i\\}_{i=1}^{N}\n\\{\\lambda_i\\}_{i=1}^{N}\n, \n\\{\\mu_i\\}_{i=1}^{N}\n\\{\\mu_i\\}_{i=1}^{N}\n, \n\\{u_i\\}_{i=1}^{N}\n\\{u_i\\}_{i=1}^{N}\n, \n\\{x_i\\}_{i=1}^{N}\n\\{x_i\\}_{i=1}^{N}\n, \n\\{p_i\\}_{i=1}^{N}\n\\{p_i\\}_{i=1}^{N}\n, and \n\\{\\Lambda_i\\}_{i=1}^{N}\n\\{\\Lambda_i\\}_{i=1}^{N}\n along the prediction horizon into \nDoP\n pieces:\n\nsizeSeg\n     \n=\n \nN\n/\nDoP\n;\n\n\nlambdaSplit\n \n=\n \nreshape\n(\nlambda\n,\n \nlambdaDim\n,\n  \nsizeSeg\n,\nDoP\n);\n\n\nmuSplit\n     \n=\n \nreshape\n(\nmu\n,\n     \nmuDim\n,\n      \nsizeSeg\n,\nDoP\n);\n\n\nuSplit\n      \n=\n \nreshape\n(\nu\n,\n      \nuDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\nxSplit\n      \n=\n \nreshape\n(\nx\n,\n      \nxDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\npSplit\n      \n=\n \nreshape\n(\npar\n,\n    \npDim\n,\n       \nsizeSeg\n,\nDoP\n);\n\n\nLAMBDASplit\n \n=\n \nreshape\n(\nLAMBDA\n,\n \nxDim\n,\n \nxDim\n,\n \nsizeSeg\n,\nDoP\n);\n\n\n\n\n\n\n\n\nGenerate dll (lib or mex) and copy it to the working directory:\n\nargs_NMPC_Iter\n \n=\n \n{\nx0\n,\n...\n\n                  \nlambdaSplit\n,\n...\n\n                  \nmuSplit\n,\n...\n\n                  \nuSplit\n,\n...\n\n                  \nxSplit\n,\n...\n\n                  \npSplit\n,\n...\n\n                  \nLAMBDASplit\n};\n\n\nNMPC_Iter_CodeGen\n(\ndll\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\ncopyfile\n(\n./codegen/dll/NMPC_Iter/NMPC_Iter.dll\n);\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\n./Simu_Simulink.slx\n\n\n\n\n\n\nNote\n\n\nThis example shows how to call the generated C interface in Simulink using the \ncoder.cevel\n function within a \nMATLAB Function\n block. \nYou can also call the C/C++ interface using S-function.\n\n\n\n\n\n\n\n\nOpen the Simulation Target pane in the Simulink Editor:\n\nSimulation \n Model Configuration Parameters \n Simulation Target\n.\n\n\n\n\n\n\nAdd \n#include\n \nNMPC_Iter.h\n to \nInsert custom C code in generated: Header file\n.\n\n\n\n\n\n\nAdd the following directory to \nAdditional Build Information: Include directories\n:\n\n./\ncodegen\n/\ndll\n/\nNMPC_Iter\n\n\n\n\n\n\n\n\nAdd \nNMPC_Iter.lib\n to \nAdditional Build Information: Libraries\n.\n\n\n\n\n\n\nCall the generated C function in a \nMATLAB Function\n block in Simulink:\n\ncoder\n.\nceval\n(\nNMPC_Iter\n,\n...\n\n             \nx0\n,\n...\n\n             \ncoder\n.\nref\n(\nlambdaSplit\n),\n...\n\n             \ncoder\n.\nref\n(\nmuSplit\n),\n... (optional)\n\n             \ncoder\n.\nref\n(\nuSplit\n),\n...\n\n             \ncoder\n.\nref\n(\nxSplit\n),\n...\n\n             \ncoder\n.\nref\n(\npSplit\n),\n...  (optional)\n\n             \ncoder\n.\nref\n(\nLAMBDASplit\n),\n...\n\n             \ncoder\n.\nwref\n(\ncost\n),\n...\n\n             \ncoder\n.\nwref\n(\nerror\n),\n...\n\n             \ncoder\n.\nwref\n(\ntimeElapsed\n));\n\n\n\n\n\n\n\n\nAccelerating Simulation using MEX-function\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\n./Simu_Simulink_Setup.m\n\n\n\n\nFollowing the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to \nmex\n:\n\nNMPC_Iter_CodeGen\n(\nmex\n,\nC\n,\nargs_NMPC_Iter\n);\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\n./Simu_Matlab.m\n\n\n\n\nModify \nNMPC_Iter\n to \nNMPC_Iter_mex\n to call the generated \nmex\n function:\n\n[\nlambdaSplit\n,\nmuSplit\n,\nuSplit\n,\nxSplit\n,\n...\n\n \nLAMBDASplit\n,\ncost\n,\nerror\n,\ntimeElapsed\n]\n \n=\n\n \nNMPC_Iter_mex\n(\nx0\n,\nlambdaSplit\n,\nmuSplit\n,\n...\n\n               \nuSplit\n,\nxSplit\n,\npSplit\n,\n...\n\n               \nLAMBDASplit\n);\n\n\n\nand run.\n\n\nMEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.\n\n\n\n\n\n\nFile Dependency\n\n\n\n\n\n\n\n\n\nLegend\uff1a\n\n\n\n\n\n\n\nAdvanced Functions\n\n\n\n\n\n\nFrom the file dependency, you can even edit directly, e.g., \nOCP_F_Fu_Fx\n, to specify your own dynamic function \nF(u,x,p)\nF(u,x,p)\n, and its Jacobians \n\\partial F/\\partial u\n\\partial F/\\partial u\n and \n\\partial F/\\partial x\n\\partial F/\\partial x\n rather than using the auto-generated \nOCP_GEN_~.m\n.\n\n\n\n\n\n\nCurrently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling \nSIM_GEN_~.m\n.", 
            "title": "Workflow"
        }, 
        {
            "location": "/workflow/#workflow-of-parnmpc", 
            "text": "", 
            "title": "Workflow of ParNMPC"
        }, 
        {
            "location": "/workflow/#preparation", 
            "text": "Choose a compiler that supports code generation with OpenMP by  mex -setup .  Edit  Timer.m  to specify your own timer function.", 
            "title": "Preparation"
        }, 
        {
            "location": "/workflow/#nmpc-problem-formulation", 
            "text": "Example  ./NMPC_Problem_Definition.m     Formulate an OCP using Class  OptimalControlProblem  % Create an OptimalControlProblem object  OCP   =   OptimalControlProblem ( muDim , ... % constraints dim \n                             uDim , ...  % inputs dim \n                             xDim , ...  % states dim \n                             pDim , ...  % parameters dim (position reference) \n                             T , ...     % prediction horizon \n                             N );         % num of discritization grids  % Give names to x, u, p (optional)                            [ ~ ]   =   OCP . setStateName ( ~ );  [ ~ ]   =   OCP . setInputName ( ~ );  [ ~ ]   =   OCP . setParameterName ( ~ );  % Reset the prediction horizon T   % (optional for variable horizon or nonuniform discretization)  OCP . setT ( ~ );  % Set the dynamic function f  OCP . setf ( ~ );  % Set the matrix M (optional for, e.g., Lagrange model)  OCP . setM ( ~ );  % Set the equality constraint function C (optional)  OCP . setC ( ~ );  % Set the cost function L  OCP . setL ( ~ );  % Set the bound constraints (optional)  OCP . setUpperBound ( u , ~ );  OCP . setLowerBound ( u , ~ );  OCP . setUpperBound ( x , ~ );  OCP . setLowerBound ( x , ~ );  % Set the polytopic constraint G (optional)  OCP . setG ( ~ );  OCP . setUpperBound ( G , ~ );  OCP . setLowerBound ( G , ~ );  % Generate necessary files  OCP . codeGen ();     Configrate the solver using Class  NMPCSolver  % Create a NMPCSolver object  nmpcSolver   =   NMPCSolver ( OCP );  % Configurate the Hessian approximation method  nmpcSolver . setHessianApproximation ( ~ );  % Generate necessary files  nmpcSolver . codeGen ();     Solve the very first OCP for a given initial state and given parameters using Class  OCPSolver  % Set the initial state       x0   =   [ ~ ];  % Set the parameters          par   =   [ ~ ];  % Create an OCPSolver object  ocpSolver   =   OCPSolver ( OCP , nmpcSolver , x0 , par );  % Choose one of the following methods to provide an initial guess:  % 1. init guess by input  lambdaInitGuess   =   [ ~ ];  muInitGuess       =   [ ~ ];  uInitGuess        =   [ ~ ];  xInitGuess        =   [ ~ ];  % 2. init guess by interpolation  [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ]   =   ... \n     ocpSolver . initFromStartEnd ( ~ );  % 3. init guess from file  [ lambdaInitGuess , muInitGuess , uInitGuess , xInitGuess ]   =   ... \n                         ocpSolver . initFromMatFile ( ~ );  % Solve the OCP                       [ lambda , mu , u , x ]   =   ocpSolver . OCPSolve ( lambdaInitGuess , ... \n                                      muInitGuess , ... \n                                      uInitGuess , ... \n                                      xInitGuess , ... \n                                      method ... \n                                      maxIter );  % Get the dependent variable LAMBDA  LAMBDA   =   ocpSolver . getLAMBDA ( x0 , lambda , mu , u , x , par );  % Check the cost % (optional)  cost   =   ocpSolver . getCost ( u , x , par );   % Save to file for further use  save   GEN_initData . mat    ... \n      x0   lambda   mu   u   x   par   LAMBDA   ~     Define the controlled plant using Class  DynamicSystem  (optional for simulation) % Create a DynamicSystem object  plant   =   DynamicSystem ( uDim , xDim , pDim );  % Give names to x, u, p (optional)  [ ~ ]   =   plant . setStateName ( ~ );  [ ~ ]   =   plant . setInputName ( ~ );  [ ~ ]   =   plant . setParameterName ( ~ );  % Set the dynamic function f  plant . setf ( ~ );  % Set the matrix M (optional for, e.g., Lagrange model)  plant . setM ( ~ );  % Generate necessary files  plant . codeGen ();     Configuration Table:      Configurable discretization method  Configurable Hessian approximation method      M  enabled  Euler  GaussNewton    M  disabled  Euler ,  RK4  Newton ,  GaussNewton  when  Euler ; GaussNewton  when  RK4 ;", 
            "title": "NMPC Problem Formulation "
        }, 
        {
            "location": "/workflow/#code-generation-and-deployment", 
            "text": "", 
            "title": "Code Generation and Deployment"
        }, 
        {
            "location": "/workflow/#matlab", 
            "text": "Here, assume your closed-loop simulation is performed in  Simu_Matlab.m .   Example  ./Simu_Matlab.m", 
            "title": "MATLAB"
        }, 
        {
            "location": "/workflow/#code-generation", 
            "text": "Example  ./Simu_Matlab_Codegen.m     Declare global variables as constants: global   discretizationMethod   isMEnabled   ... \n        uMin   uMax   xMin   xMax   GMax   GMin   ... \n        veryBigNum  globalVariable   =   { discretizationMethod , coder . Constant ( discretizationMethod ), ... \n                   isMEnabled , coder . Constant ( isMEnabled ), ... \n                   uMax , coder . Constant ( uMax ), ... \n                   uMin , coder . Constant ( uMin ), ... \n                   xMax , coder . Constant ( xMax ), ... \n                   xMin , coder . Constant ( xMin ), ... \n                   GMax , coder . Constant ( GMax ), ... \n                   GMin , coder . Constant ( GMin ), ... \n                   veryBigNum , coder . Constant ( veryBigNum )};     Generate code using  codegen : codegen   - config : lib   Simu_Matlab   - globals   globalVariable   \nC code will be automatically generated to  ./codegen/lib/Simu_Matlab .", 
            "title": "Code generation"
        }, 
        {
            "location": "/workflow/#deployment-in-visual-studio", 
            "text": "Create an empty Win32 Console Application project.    Change to Release x64 mode.    Add   *.h  and  *.c  files in  .\\codegen\\lib\\Simu_Matlab  to the project.    Add   main.h  and  main.c  in  .\\codegen\\lib\\Simu_Matlab\\examples  to the project.    Add directory  .\\codegen\\lib\\Simu_Matlab  to  Properties   C/C++   General    Additional Include Directories .    Properties   C/C++   Language    Open MP Support: Yes (/openmp) .    Compile and run.", 
            "title": "Deployment in Visual Studio"
        }, 
        {
            "location": "/workflow/#simulink", 
            "text": "Here, assume your closed-loop simulation is performed in Simulink. You can call the generated C/C++ solver function  NMPC_Iter  directly to compute the optimal input.", 
            "title": "Simulink "
        }, 
        {
            "location": "/workflow/#code-generation_1", 
            "text": "Example  ./Simu_Simulink_Setup.m     Define the degree of parallelism: DoP   =   ~ ;   % degree of parallism: 1 = in serial, otherwise in parallel     Split  \\{\\lambda_i\\}_{i=1}^{N} \\{\\lambda_i\\}_{i=1}^{N} ,  \\{\\mu_i\\}_{i=1}^{N} \\{\\mu_i\\}_{i=1}^{N} ,  \\{u_i\\}_{i=1}^{N} \\{u_i\\}_{i=1}^{N} ,  \\{x_i\\}_{i=1}^{N} \\{x_i\\}_{i=1}^{N} ,  \\{p_i\\}_{i=1}^{N} \\{p_i\\}_{i=1}^{N} , and  \\{\\Lambda_i\\}_{i=1}^{N} \\{\\Lambda_i\\}_{i=1}^{N}  along the prediction horizon into  DoP  pieces: sizeSeg       =   N / DoP ;  lambdaSplit   =   reshape ( lambda ,   lambdaDim ,    sizeSeg , DoP );  muSplit       =   reshape ( mu ,       muDim ,        sizeSeg , DoP );  uSplit        =   reshape ( u ,        uDim ,         sizeSeg , DoP );  xSplit        =   reshape ( x ,        xDim ,         sizeSeg , DoP );  pSplit        =   reshape ( par ,      pDim ,         sizeSeg , DoP );  LAMBDASplit   =   reshape ( LAMBDA ,   xDim ,   xDim ,   sizeSeg , DoP );     Generate dll (lib or mex) and copy it to the working directory: args_NMPC_Iter   =   { x0 , ... \n                   lambdaSplit , ... \n                   muSplit , ... \n                   uSplit , ... \n                   xSplit , ... \n                   pSplit , ... \n                   LAMBDASplit };  NMPC_Iter_CodeGen ( dll , C , args_NMPC_Iter );  copyfile ( ./codegen/dll/NMPC_Iter/NMPC_Iter.dll );", 
            "title": "Code generation"
        }, 
        {
            "location": "/workflow/#deployment", 
            "text": "Example  ./Simu_Simulink.slx    Note  This example shows how to call the generated C interface in Simulink using the  coder.cevel  function within a  MATLAB Function  block. \nYou can also call the C/C++ interface using S-function.     Open the Simulation Target pane in the Simulink Editor: Simulation   Model Configuration Parameters   Simulation Target .    Add  #include   NMPC_Iter.h  to  Insert custom C code in generated: Header file .    Add the following directory to  Additional Build Information: Include directories : ./ codegen / dll / NMPC_Iter     Add  NMPC_Iter.lib  to  Additional Build Information: Libraries .    Call the generated C function in a  MATLAB Function  block in Simulink: coder . ceval ( NMPC_Iter , ... \n              x0 , ... \n              coder . ref ( lambdaSplit ), ... \n              coder . ref ( muSplit ), ... (optional) \n              coder . ref ( uSplit ), ... \n              coder . ref ( xSplit ), ... \n              coder . ref ( pSplit ), ...  (optional) \n              coder . ref ( LAMBDASplit ), ... \n              coder . wref ( cost ), ... \n              coder . wref ( error ), ... \n              coder . wref ( timeElapsed ));", 
            "title": "Deployment"
        }, 
        {
            "location": "/workflow/#accelerating-simulation-using-mex-function", 
            "text": "Code generation   Example  ./Simu_Simulink_Setup.m   Following the code generation for Simulink procedure, MEX-function can be generated by modifying the generation target to  mex : NMPC_Iter_CodeGen ( mex , C , args_NMPC_Iter );     Deployment   Example  ./Simu_Matlab.m   Modify  NMPC_Iter  to  NMPC_Iter_mex  to call the generated  mex  function: [ lambdaSplit , muSplit , uSplit , xSplit , ... \n  LAMBDASplit , cost , error , timeElapsed ]   = \n  NMPC_Iter_mex ( x0 , lambdaSplit , muSplit , ... \n                uSplit , xSplit , pSplit , ... \n                LAMBDASplit );  \nand run.  MEX-function is typically slower than C code. However, it can speed up your simulation to check the closed-loop response.", 
            "title": "Accelerating Simulation using MEX-function"
        }, 
        {
            "location": "/workflow/#file-dependency", 
            "text": "Legend\uff1a", 
            "title": "File Dependency"
        }, 
        {
            "location": "/workflow/#advanced-functions", 
            "text": "From the file dependency, you can even edit directly, e.g.,  OCP_F_Fu_Fx , to specify your own dynamic function  F(u,x,p) F(u,x,p) , and its Jacobians  \\partial F/\\partial u \\partial F/\\partial u  and  \\partial F/\\partial x \\partial F/\\partial x  rather than using the auto-generated  OCP_GEN_~.m .    Currently, only the 4-th order Runge-Kutta method is provided to simulate the controlled plant. You can also program your own method by calling  SIM_GEN_~.m .", 
            "title": "Advanced Functions"
        }, 
        {
            "location": "/exp_damper/", 
            "text": "Semi-active Damper\n\n\n\n\nExample\n\n\nSemiActiveDamper/\n\n\n\n\nProblem Description\n\n\nA vehicle contacts the wall through the spring and damper: \n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the system is \nx=[y,\\dot{y}]^T\nx=[y,\\dot{y}]^T\n, where \ny\ny\n is the position of the vehicle. \n\n\n\n\n\n\nThe input is the damping coefficient \nd\nd\n, which is constrained with  \n0\\leq d \\leq 1\n0\\leq d \\leq 1\n.\n\n\n\n\n\n\nThe dynamic equation of this semi-active damper is \nm\\ddot{y} = -ky-d\\dot{y}\nm\\ddot{y} = -ky-d\\dot{y}\n, where \nk = 1\nk = 1\n and \nm=1\nm=1\n.\n\n\n\n\n\n\nThe task is to control the vehicle's position \ny\ny\n to 0 from an initial position.\n\n\nOCP in \nParNMPC\n\n\nThe inequality constraints are transfered into equality constraints by introducing an extra dummy input \nd_s\nd_s\n. \n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[y,\\dot{y}]^T\nx=[y,\\dot{y}]^T\n.\n\n\nInput: \nu=[d,d_s]\nu=[d,d_s]\n.\n\n\nParameter: \np\np\n is empty.\n\n\nL(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s\nL(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s\n.\n\n\nC(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4}\nC(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4}\n.\n\n\nf(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T\nf(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T\n.\n\n\nPrediction horizon \nT=5\nT=5\n.\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler.\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nSemiActiveDamper/NMPC_Problem_Formulation.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nSemiActiveDamper/Simu_Simulink.slx", 
            "title": "Simulation: Semi-active Damper"
        }, 
        {
            "location": "/exp_damper/#semi-active-damper", 
            "text": "Example  SemiActiveDamper/", 
            "title": "Semi-active Damper"
        }, 
        {
            "location": "/exp_damper/#problem-description", 
            "text": "A vehicle contacts the wall through the spring and damper:        The state vector of the system is  x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T , where  y y  is the position of the vehicle.     The input is the damping coefficient  d d , which is constrained with   0\\leq d \\leq 1 0\\leq d \\leq 1 .    The dynamic equation of this semi-active damper is  m\\ddot{y} = -ky-d\\dot{y} m\\ddot{y} = -ky-d\\dot{y} , where  k = 1 k = 1  and  m=1 m=1 .    The task is to control the vehicle's position  y y  to 0 from an initial position.", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_damper/#ocp-in-parnmpc", 
            "text": "The inequality constraints are transfered into equality constraints by introducing an extra dummy input  d_s d_s .   The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[y,\\dot{y}]^T x=[y,\\dot{y}]^T .  Input:  u=[d,d_s] u=[d,d_s] .  Parameter:  p p  is empty.  L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s L(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 - rd_s .  C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} C(u,x,p) = (d-\\frac{1}{2})^2 + d_s^2-\\frac{1}{4} .  f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T f(u,x,p) = [\\dot{y},-y-d\\dot{y}]^T .  Prediction horizon  T=5 T=5 .  Number of the discritization grids  N=48 N=48 .  Discretization method: Euler.", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_damper/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_damper/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  SemiActiveDamper/NMPC_Problem_Formulation.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_damper/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  SemiActiveDamper/Simu_Simulink_Setup.m     Deployment   Example  SemiActiveDamper/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_double_pendulum/", 
            "text": "Double Inverted Pendulum on a Cart\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/\n\n\n\n\n\n\nWhere you can find this pendulum\n\n\nA. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.\n\n\n\n\nProblem Description\n\n\nSwing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. \nThe pendulum we want to swing up is:\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the system is \nx =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T}\nx =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T}\n, where \n\\theta_0\n\\theta_0\n is the displacement of the cart, and where \n\\theta_1\n\\theta_1\n, \n\\theta_2\n\\theta_2\n are the pendulum angles.\n\n\n\n\n\n\nThe control force \nu\nu\n is constrained with  \n|u|\\leq 10\n|u|\\leq 10\n.\n\n\n\n\n\n\nThe system is modeled as \nD(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu\nD(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu\n with \n\\theta=[\\theta_0,\\theta_1,\\theta_2]^T\n\\theta=[\\theta_0,\\theta_1,\\theta_2]^T\n.\n\n\n\n\n\n\nA terminal penalty function is imposed to swing up the pendulum.\n\n\n\n\n\n\nThe task is to swing up the pendulum from the initial state \nx_0 =  [0,\\pi,\\pi,0,0,0]^{T}\nx_0 =  [0,\\pi,\\pi,0,0,0]^{T}\n.\n\n\nOCP in \nParNMPC\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T\nx=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T\n.\n\n\nInput: \nu\nu\n with \nu_{max} = 10\nu_{max} = 10\n and \nu_{min} = -10\nu_{min} = -10\n.\n\n\nParameter: \np=[Q_d,R_d,\\gamma]\np=[Q_d,R_d,\\gamma]\n.\n\n\n\n\nL(u,x,p)  = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2\nL(u,x,p)  = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2\n with \nQ=\\text{diag}(Q_d)\nQ=\\text{diag}(Q_d)\n and \nR=\\text{diag}(R_d)\nR=\\text{diag}(R_d)\n.\n\n\n\n\n\n\nf(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}]\nf(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}]\n.\n\n\n\n\n\n\nM(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta))\nM(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta))\n.\n\n\n\n\n\n\nPrediction horizon \nT=1.5\nT=1.5\n.\n\n\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler.\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/NMPC_Problem_Formulation.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nDoubleInvertedPendulum/Simu_Simulink.slx", 
            "title": "Simulation: Double Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_double_pendulum/#double-inverted-pendulum-on-a-cart", 
            "text": "Example  DoubleInvertedPendulum/    Where you can find this pendulum  A. Bogdanov, \u201cOptimal control of a double inverted pendulum on a cart,\u201d Oregon Health and Science University, Tech. Rep. CSE-04-006, OGI School of Science and Engineering, Beaverton, OR, 2004.", 
            "title": "Double Inverted Pendulum on a Cart"
        }, 
        {
            "location": "/exp_double_pendulum/#problem-description", 
            "text": "Swing-up control of a double inverted pendulum on a cart is a benchmark problem for NMPC algorithms due to its high nonlinearity. \nThe pendulum we want to swing up is:       The state vector of the system is  x =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T} x =  [\\theta_0,\\dot{\\theta}_0  , \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^{T} , where  \\theta_0 \\theta_0  is the displacement of the cart, and where  \\theta_1 \\theta_1 ,  \\theta_2 \\theta_2  are the pendulum angles.    The control force  u u  is constrained with   |u|\\leq 10 |u|\\leq 10 .    The system is modeled as  D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu D(\\theta)\\ddot{\\theta}+C(\\theta,\\dot{\\theta})\\dot{\\theta}+G(\\theta)=Hu  with  \\theta=[\\theta_0,\\theta_1,\\theta_2]^T \\theta=[\\theta_0,\\theta_1,\\theta_2]^T .    A terminal penalty function is imposed to swing up the pendulum.    The task is to swing up the pendulum from the initial state  x_0 =  [0,\\pi,\\pi,0,0,0]^{T} x_0 =  [0,\\pi,\\pi,0,0,0]^{T} .", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_double_pendulum/#ocp-in-parnmpc", 
            "text": "The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T x=[\\theta_0,\\dot{\\theta}_0, \\theta_1 ,\\dot{\\theta}_1 ,\\theta_2  ,\\dot{\\theta}_2]^T=[\\theta,\\dot{\\theta}]^T .  Input:  u u  with  u_{max} = 10 u_{max} = 10  and  u_{min} = -10 u_{min} = -10 .  Parameter:  p=[Q_d,R_d,\\gamma] p=[Q_d,R_d,\\gamma] .   L(u,x,p)  = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2 L(u,x,p)  = \\frac{1}{2}\\|x\\|_{Q}^2+\\frac{1}{2}\\|u\\|_{R}^2  with  Q=\\text{diag}(Q_d) Q=\\text{diag}(Q_d)  and  R=\\text{diag}(R_d) R=\\text{diag}(R_d) .    f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] f(u,x,p)=[\\dot{\\theta};Hu-G(\\theta)-C(\\theta,\\dot{\\theta})\\dot{\\theta}] .    M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) M(u,x,p) = \\text{blkdiag}(\\text{eye(3)},D(\\theta)) .    Prediction horizon  T=1.5 T=1.5 .   Number of the discritization grids  N=48 N=48 .  Discretization method: Euler.", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_double_pendulum/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_double_pendulum/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  DoubleInvertedPendulum/NMPC_Problem_Formulation.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_double_pendulum/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  DoubleInvertedPendulum/Simu_Simulink_Setup.m     Deployment   Example  DoubleInvertedPendulum/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_quadrotor/", 
            "text": "Quadrotor\n\n\n\n\nExample\n\n\nQuadrotor/\n\n\n\n\n\n\nWhere you can find this quadrotor\n\n\nM. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d \nICRA, Shanghai, China, 2011, pp. 763\u2013770.\n\n\n\n\nProblem Description\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the quadrotor is \nx =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9}\nx =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9}\n, where \n(X,Y,Z)\n(X,Y,Z)\n and \n(\\gamma,\\beta,\\alpha)\n(\\gamma,\\beta,\\alpha)\n are the position and angles of the quadrotor, respectively. The state is bounded by \n[-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T\n[-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T\n.\n\n\n\n\n\n\nThe input vector is \nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T\nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T\n, where \na\na\n represents the thrust and \n(\\omega_{X},\\omega_{Y},\\omega_{Z})\n(\\omega_{X},\\omega_{Y},\\omega_{Z})\n the rotational rates. The control input is bounded by \n[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T\n[0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T\n. \n\n\n\n\n\n\nThe dynamics of the quadrotor are given by the following equations:\n\n\n\n\n\n\n\n\n\\begin{align}\n\n\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n\n\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n\n\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n\n\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n\n\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n\n\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}\n\n\n\\begin{align}\n&\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n&\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n&\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n&\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n&\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n&\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}\n\n\n\n\nThe task is to control the quadrotor to track a given position reference under a variable prediction horizon.\n\n\nOCP in \nParNMPC\n\n\nThe state constraints are softened by introducing slack variables \n\\dot{X}_s\n\\dot{X}_s\n, \n\\dot{Y}_s\n\\dot{Y}_s\n, and \n\\dot{Z}_s\n\\dot{Z}_s\n.\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T\nx=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T\n.\n\n\nInput: \nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T\nu=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T\n with \nu_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T\nu_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T\n and \nu_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T\nu_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T\n.\n\n\nParameter: \np=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T\np=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T\n, where \n\\gamma\n0\n\\gamma>0\n is the barrier parameter.\n\n\nCost function \nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\n, where \nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\n with \nx_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T\nx_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T\n, and \nL_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2)\nL_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2)\n is the penalty function.\n\n\nPolytopic function (linear constraint): \nG = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T\nG = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T\n with \nG_{max}=[1,\\infty,1,\\infty,1,\\infty]^T\nG_{max}=[1,\\infty,1,\\infty,1,\\infty]^T\n and \nG_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T\nG_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T\n.\n\n\nf(u,x,p)\nf(u,x,p)\n is shown before.\n\n\nPrediction horizon \nT\nT\n.\n\n\nNumber of the discritization grids \nN=40\nN=40\n.\n\n\nDiscretization method: Euler.\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nQuadrotor/NMPC_Problem_Formulation.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nQuadrotor/Simu_Simulink.slx", 
            "title": "Simulation: Quadrotor"
        }, 
        {
            "location": "/exp_quadrotor/#quadrotor", 
            "text": "Example  Quadrotor/    Where you can find this quadrotor  M. Hehn and R. D\u2019Andrea, \u201cA flying inverted pendulum,\u201d \nICRA, Shanghai, China, 2011, pp. 763\u2013770.", 
            "title": "Quadrotor"
        }, 
        {
            "location": "/exp_quadrotor/#problem-description", 
            "text": "The state vector of the quadrotor is  x =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9} x =  [X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^{T}\\in\\mathbb{R}^{9} , where  (X,Y,Z) (X,Y,Z)  and  (\\gamma,\\beta,\\alpha) (\\gamma,\\beta,\\alpha)  are the position and angles of the quadrotor, respectively. The state is bounded by  [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T [-1,-1,-1]^T \\leq [\\dot{X},\\dot{Y},\\dot{Z}]^T \\leq [1,1,1]^T .    The input vector is  u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z}]^T , where  a a  represents the thrust and  (\\omega_{X},\\omega_{Y},\\omega_{Z}) (\\omega_{X},\\omega_{Y},\\omega_{Z})  the rotational rates. The control input is bounded by  [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T [0,-1,-1,-1]^T \\leq u \\leq [11,1,1,1]^T .     The dynamics of the quadrotor are given by the following equations:     \\begin{align} \\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\ \\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\ \\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\ \\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\ \\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\ \\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}  \\begin{align}\n&\\ddot{X} = a(\\cos\\gamma\\sin\\beta\\cos\\alpha+\\sin\\gamma\\sin\\alpha)\\\\\n&\\ddot{Y} = a(\\cos\\gamma\\sin\\beta\\sin\\alpha-\\sin\\gamma\\cos\\alpha)\\\\\n&\\ddot{Z} = a\\cos\\gamma\\cos\\beta-g\\\\\n&\\dot{\\gamma}  =  (\\omega_{X}\\cos\\gamma+\\omega_{Y}\\sin\\gamma)/\\cos\\beta\\\\\n&\\dot{\\beta} = -\\omega_{X}\\sin\\gamma+\\omega_{Y}\\cos\\gamma\\\\\n&\\dot{\\alpha} = \\omega_{X}\\cos\\gamma\\tan\\beta + \\omega_{Y}\\sin\\gamma\\tan\\beta+\\omega_{Z}\n\\end{align}   The task is to control the quadrotor to track a given position reference under a variable prediction horizon.", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_quadrotor/#ocp-in-parnmpc", 
            "text": "The state constraints are softened by introducing slack variables  \\dot{X}_s \\dot{X}_s ,  \\dot{Y}_s \\dot{Y}_s , and  \\dot{Z}_s \\dot{Z}_s .  The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T x=[X,\\dot{X}  , Y ,\\dot{Y} ,Z  ,\\dot{Z} ,\\gamma ,\\beta  ,\\alpha ]^T .  Input:  u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T u=[a,\\omega_{X},\\omega_{Y},\\omega_{Z},\\dot{X}_s,\\dot{Y}_s,\\dot{Z}_s]^T  with  u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T u_{max}=[11,1,1,1,\\infty,\\infty,\\infty]^T  and  u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T u_{min} = [0,-1,-1,-1, 0, 0, 0 ]^T .  Parameter:  p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T p=[X_{ref},Y_{ref},Z_{ref},\\gamma,T]^T , where  \\gamma 0 \\gamma>0  is the barrier parameter.  Cost function  L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where  L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2  with  x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T x_{ref}=[X_{ref},0,Y_{ref},0,Z_{ref},0,0,0,0]^T , and  L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2) L_{penalty}(u,x,p)=1000(\\dot{X}_s^2 +\\dot{Y}_s^2 + \\dot{Z}_s^2)  is the penalty function.  Polytopic function (linear constraint):  G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T G = [\\dot{X} - \\dot{X}_s, \\dot{X} + \\dot{X}_s,\\dot{Y} - \\dot{Y}_s, \\dot{Y} + \\dot{Y}_s, \\dot{Z} - \\dot{Z}_s, \\dot{Z} + \\dot{Z}_s]^T  with  G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T G_{max}=[1,\\infty,1,\\infty,1,\\infty]^T  and  G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T G_{min} = [-\\infty,-1,-\\infty,-1,-\\infty,-1]^T .  f(u,x,p) f(u,x,p)  is shown before.  Prediction horizon  T T .  Number of the discritization grids  N=40 N=40 .  Discretization method: Euler.", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_quadrotor/#closed-loop-simulation-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_quadrotor/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  Quadrotor/NMPC_Problem_Formulation.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_quadrotor/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  Quadrotor/Simu_Simulink_Setup.m     Deployment   Example  Quadrotor/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_vehicle/", 
            "text": "Vehicle\n\n\n\n\nExample\n\n\nVehicle/\n\n\n\n\nProblem Description\n\n\n\n\n\n\nThe state vector of the vehicle is \nx =  [y,z  , v ,\\theta]^{T}\\in\\mathbb{R}^{4}\nx =  [y,z  , v ,\\theta]^{T}\\in\\mathbb{R}^{4}\n, where \n(y,z)\n(y,z)\n is the position coordinate, \nv\nv\n is the velocity, and \n\\theta\n\\theta\n is the heading angle. \n\n\n\n\n\n\nThe input vector is \nu=[F,s]^T\nu=[F,s]^T\n, where \nF\nF\n is the acceleration force and \ns\ns\n is the steering torque. The control input is bounded by \n[-5,-1]^T \\leq u \\leq [5,1]^T\n[-5,-1]^T \\leq u \\leq [5,1]^T\n.\n\n\n\n\n\n\nThe vehicle starts from position \n(-2,0)\n(-2,0)\n. It's aim is to reach \n(3.5,2)\n(3.5,2)\n while avoiding two obstacles with positions \n(0,0)\n(0,0)\n and \n(2,2)\n(2,2)\n. These constraints are formulated as \ny^2+z^2\\geq 1\ny^2+z^2\\geq 1\n and \n(y-2)^2+(z-2)^2\\geq 1\n(y-2)^2+(z-2)^2\\geq 1\n.\n\n\n\n\n\n\nThe dynamics of the vehicle are given by the following equations (\nm\nm\n: mass and \nI\nI\n: moment of inertia):\n\n\n\n\n\n\n\n\n\\begin{align}\n\n\\dot{y} = v\\cos(\\theta)\\\\\n\n\\dot{z} = v\\sin(\\theta)\\\\\n\n\\dot{v} = F/m\\\\\n\n\\dot{\\theta}  =  s/I\n\\end{align}\n\n\n\\begin{align}\n&\\dot{y} = v\\cos(\\theta)\\\\\n&\\dot{z} = v\\sin(\\theta)\\\\\n&\\dot{v} = F/m\\\\\n&\\dot{\\theta}  =  s/I\n\\end{align}\n\n\n\n\nOCP in \nParNMPC\n\n\nFirst, the state constraints are transfered into \ny^2+z^2 =  C_{s1}\ny^2+z^2 =  C_{s1}\n and \n(y-2)^2+(z-2)^2 =  C_{s2}\n(y-2)^2+(z-2)^2 =  C_{s2}\n with \nC_{s1}\\geq 1\nC_{s1}\\geq 1\n and \nC_{s2}\\geq 2\nC_{s2}\\geq 2\n. Next, \nC_{s1}\\geq 1\nC_{s1}\\geq 1\n and \nC_{s2}\\geq 2\nC_{s2}\\geq 2\n are softened by introducing slack variables \nC_{ss1}\nC_{ss1}\n and \nC_{ss2}\nC_{ss2}\n.\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[y,z  , v ,\\theta]^T\nx=[y,z  , v ,\\theta]^T\n.\n\n\nInput: \nu=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T\nu=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T\n with \nu_{max}=[5,  1,  \\infty, \\infty,  \\infty, \\infty]^T\nu_{max}=[5,  1,  \\infty, \\infty,  \\infty, \\infty]^T\n and \nu_{min} = [-5, -1, -\\infty, 0,   -\\infty, 0 ]^T\nu_{min} = [-5, -1, -\\infty, 0,   -\\infty, 0 ]^T\n.\n\n\nParameter: \np=\\gamma\np=\\gamma\n, where \n\\gamma\n0\n\\gamma>0\n is the barrier parameter.\n\n\nEquality constraint \nC(u,x,p) = [y^2    + z^2     - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T\nC(u,x,p) = [y^2    + z^2     - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T\n.\n\n\nCost function \nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\n, where \nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2\n with \nx_{ref}=[3.5,2,0,0]\nx_{ref}=[3.5,2,0,0]\n, and \nL_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2)\nL_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2)\n is the penalty function.\n\n\nPolytopic function (linear constraint) \nG = [C_{s1} - C_{ss1},C_{s1} + C_{ss1},     C_{s2} - C_{ss2},     C_{s2} + C_{ss2}]^T\nG = [C_{s1} - C_{ss1},C_{s1} + C_{ss1},     C_{s2} - C_{ss2},     C_{s2} + C_{ss2}]^T\n with \nG_{max}=[\\infty,\\infty,\\infty,\\infty]^T\nG_{max}=[\\infty,\\infty,\\infty,\\infty]^T\n and \nG_{min} = [-\\infty,1,-\\infty,1]^T\nG_{min} = [-\\infty,1,-\\infty,1]^T\n.\n\n\nf(u,x,p)\nf(u,x,p)\n is shown before.\n\n\nPrediction horizon \nT=3\nT=3\n s.\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler.\n\n\n\n\nClosed-loop Simulation using \nParNMPC\n\n\nClosed-loop simulation result:\n\n\n\n\n\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nVehicle/NMPC_Problem_Formulation.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nVehicle/Simu_Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nVehicle/Simu_Simulink.slx", 
            "title": "Simulation: Vehicle"
        }, 
        {
            "location": "/exp_vehicle/#vehicle", 
            "text": "Example  Vehicle/", 
            "title": "Vehicle"
        }, 
        {
            "location": "/exp_vehicle/#problem-description", 
            "text": "The state vector of the vehicle is  x =  [y,z  , v ,\\theta]^{T}\\in\\mathbb{R}^{4} x =  [y,z  , v ,\\theta]^{T}\\in\\mathbb{R}^{4} , where  (y,z) (y,z)  is the position coordinate,  v v  is the velocity, and  \\theta \\theta  is the heading angle.     The input vector is  u=[F,s]^T u=[F,s]^T , where  F F  is the acceleration force and  s s  is the steering torque. The control input is bounded by  [-5,-1]^T \\leq u \\leq [5,1]^T [-5,-1]^T \\leq u \\leq [5,1]^T .    The vehicle starts from position  (-2,0) (-2,0) . It's aim is to reach  (3.5,2) (3.5,2)  while avoiding two obstacles with positions  (0,0) (0,0)  and  (2,2) (2,2) . These constraints are formulated as  y^2+z^2\\geq 1 y^2+z^2\\geq 1  and  (y-2)^2+(z-2)^2\\geq 1 (y-2)^2+(z-2)^2\\geq 1 .    The dynamics of the vehicle are given by the following equations ( m m : mass and  I I : moment of inertia):     \\begin{align} \\dot{y} = v\\cos(\\theta)\\\\ \\dot{z} = v\\sin(\\theta)\\\\ \\dot{v} = F/m\\\\ \\dot{\\theta}  =  s/I\n\\end{align}  \\begin{align}\n&\\dot{y} = v\\cos(\\theta)\\\\\n&\\dot{z} = v\\sin(\\theta)\\\\\n&\\dot{v} = F/m\\\\\n&\\dot{\\theta}  =  s/I\n\\end{align}", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_vehicle/#ocp-in-parnmpc", 
            "text": "First, the state constraints are transfered into  y^2+z^2 =  C_{s1} y^2+z^2 =  C_{s1}  and  (y-2)^2+(z-2)^2 =  C_{s2} (y-2)^2+(z-2)^2 =  C_{s2}  with  C_{s1}\\geq 1 C_{s1}\\geq 1  and  C_{s2}\\geq 2 C_{s2}\\geq 2 . Next,  C_{s1}\\geq 1 C_{s1}\\geq 1  and  C_{s2}\\geq 2 C_{s2}\\geq 2  are softened by introducing slack variables  C_{ss1} C_{ss1}  and  C_{ss2} C_{ss2} .  The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[y,z  , v ,\\theta]^T x=[y,z  , v ,\\theta]^T .  Input:  u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T u=[F,s,C_{s1},C_{ss1},C_{s2},C_{ss2}]^T  with  u_{max}=[5,  1,  \\infty, \\infty,  \\infty, \\infty]^T u_{max}=[5,  1,  \\infty, \\infty,  \\infty, \\infty]^T  and  u_{min} = [-5, -1, -\\infty, 0,   -\\infty, 0 ]^T u_{min} = [-5, -1, -\\infty, 0,   -\\infty, 0 ]^T .  Parameter:  p=\\gamma p=\\gamma , where  \\gamma 0 \\gamma>0  is the barrier parameter.  Equality constraint  C(u,x,p) = [y^2    + z^2     - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T C(u,x,p) = [y^2    + z^2     - C_{s1},(y-2)^2 + (z-2)^2 - C_{s2}]^T .  Cost function  L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where  L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R}^2  with  x_{ref}=[3.5,2,0,0] x_{ref}=[3.5,2,0,0] , and  L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2) L_{penalty}(u,x,p)=1000(C_{ss1}^2 +C_{ss2}^2)  is the penalty function.  Polytopic function (linear constraint)  G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1},     C_{s2} - C_{ss2},     C_{s2} + C_{ss2}]^T G = [C_{s1} - C_{ss1},C_{s1} + C_{ss1},     C_{s2} - C_{ss2},     C_{s2} + C_{ss2}]^T  with  G_{max}=[\\infty,\\infty,\\infty,\\infty]^T G_{max}=[\\infty,\\infty,\\infty,\\infty]^T  and  G_{min} = [-\\infty,1,-\\infty,1]^T G_{min} = [-\\infty,1,-\\infty,1]^T .  f(u,x,p) f(u,x,p)  is shown before.  Prediction horizon  T=3 T=3  s.  Number of the discritization grids  N=48 N=48 .  Discretization method: Euler.", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_vehicle/#closed-loop-simulation-using-parnmpc", 
            "text": "Closed-loop simulation result:", 
            "title": "Closed-loop Simulation using ParNMPC"
        }, 
        {
            "location": "/exp_vehicle/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  Vehicle/NMPC_Problem_Formulation.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_vehicle/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  Vehicle/Simu_Simulink_Setup.m     Deployment   Example  Vehicle/Simu_Simulink.slx", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/exp_heli/", 
            "text": "Helicopter\n\n\n\n\nExample\n\n\nHelicopter/\n\n\n\n\n\n\nWhere you can find this helicopter\n\n\nQuanser website. \n3 DoF Helicopter\n. \n\nModel:\nBenchmark model of Quanser\u2019s 3 DOF Helicopter - 2018 \n\n\n\n\nProblem Description\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe state vector of the helicopter is \nx =  [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6}\nx =  [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6}\n, where \nq = [\\epsilon,\\rho,\\lambda]^T\nq = [\\epsilon,\\rho,\\lambda]^T\n is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle \n\\rho\n\\rho\n is set to be \n|\\rho|\\leq 1\n|\\rho|\\leq 1\n.\n\n\n\n\n\n\nThe input vector is \nu=[V_f,V_b]^T\nu=[V_f,V_b]^T\n, where \nV_f\nV_f\n is the voltage on the front motor and  \nV_b\nV_b\n is the voltage on the back motor. The control input is bounded by \n[0,0]^T \\leq u \\leq [20,20]^T\n[0,0]^T \\leq u \\leq [20,20]^T\n.\n\n\n\n\n\n\nThe dynamics of the helicopter are given by the following equations:\n\n\n\n\n\n\n\n\n\\begin{align*}\n\\ddot{q}\n =\n\n-\\left[\n\\begin{array}{c}\n\\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ \n-a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ \n0\n\\end{array} \n\\right]\n-\n\\left[\n\\begin{array}{ccc}\nC_\\epsilon \n  \n  \\\\ \n\n  C_\\rho\n  \\\\ \n\n  \n C_\\lambda\n\\end{array} \n\\right]\\dot{q}\\\\\n\n+K_f\n\\left[\n\\begin{array}{cc}\nb_{\\epsilon}\\cos(\\rho)\n 0 \\\\ \n0 \n  b_{\\rho}\\\\ \nb_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)\n 0\n\\end{array} \n\\right]u\n\\end{align*}\n\n\n\\begin{align*}\n\\ddot{q}\n =\n&-\\left[\n\\begin{array}{c}\n\\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ \n-a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ \n0\n\\end{array} \n\\right]\n-\n\\left[\n\\begin{array}{ccc}\nC_\\epsilon &  &  \\\\ \n&  C_\\rho&  \\\\ \n&  & C_\\lambda\n\\end{array} \n\\right]\\dot{q}\\\\\n&+K_f\n\\left[\n\\begin{array}{cc}\nb_{\\epsilon}\\cos(\\rho)& 0 \\\\ \n0 &  b_{\\rho}\\\\ \nb_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0\n\\end{array} \n\\right]u\n\\end{align*}\n\n\n\n\nThe task is to control the helicopter to track a given yaw reference.\n\n\nOCP in \nParNMPC\n\n\nThe state constraints are softened by introducing a slack variable \n\\rho_s\n\\rho_s\n.\n\n\nThe underlying OCP defined in \nParNMPC\n is formulated as:\n\n\n\n\nState: \nx=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T\nx=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T\n.\n\n\nInput: \nu=[V_f,V_b,\\rho_s]^T\nu=[V_f,V_b,\\rho_s]^T\n with \nu_{max}=[20,20,\\infty]^T\nu_{max}=[20,20,\\infty]^T\n and \nu_{min} = [0,0,0]^T\nu_{min} = [0,0,0]^T\n.\n\n\nParameter: \np=[Q_d,R_d,x_{ref},\\gamma]^T\np=[Q_d,R_d,x_{ref},\\gamma]^T\n, where \nQ_d\nQ_d\n and \nR_d\nR_d\n are tuning parameters, \nx_{ref}\nx_{ref}\n is the varying reference, and \n\\gamma\n0\n\\gamma>0\n is the barrier parameter.\n\n\nCost function \nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\nL(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p)\n, where \nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2\nL_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2\n and \nL_{penalty}(u,x,p)=1000\\rho_s^2\nL_{penalty}(u,x,p)=1000\\rho_s^2\n is the penalty function.\n\n\nPolytopic function (linear constraint): \nG = [\\rho - \\rho_s, \\rho + \\rho_s]^T\nG = [\\rho - \\rho_s, \\rho + \\rho_s]^T\n with \nG_{max}=[1,\\infty]^T\nG_{max}=[1,\\infty]^T\n and \nG_{min} = [-\\infty,-1]^T\nG_{min} = [-\\infty,-1]^T\n.\n\n\nf(u,x,p)\nf(u,x,p)\n is shown before.\n\n\nPrediction horizon \nT=4\nT=4\n s.\n\n\nNumber of the discritization grids \nN=48\nN=48\n.\n\n\nDiscretization method: Euler.\n\n\n\n\nExperiment settings:\n\n\n\n\nCPU: i7-8700K.\n\n\nMATLAB R2015b + Microsoft Visual C++ 2015 (C)\n\n\nTolerance: 1e-4.\n\n\nDoP: 4.\n\n\nHessian approximation method: Newton.\n\n\n\n\nClosed-loop control using \nParNMPC\n\n\nStep 1. NMPC problem formulation\n\n\nSee \nWorkflow of ParNMPC \n NMPC Problem Formulation\n.\n\n\n\n\nExample\n\n\nHelicopter/NMPC_Problem_Formulation.m\n\n\n\n\nStep 2. Code generation and deployment in Simulink\n\n\nSee \nWorkflow of ParNMPC \n Code Generation and Deployment \n Simulink\n.\n\n\n\n\n\n\nCode generation\n\n\n\n\nExample\n\n\nHelicopter/Simulink_Setup.m\n\n\n\n\n\n\n\n\nDeployment\n\n\n\n\nExample\n\n\nHelicopter/Deploy_Simulink_R2015b.slx\n\n\n\n\nAdd \n-openmp\n to the makefile provided by Quanser.\n\n\n\n\n\n\nExperiment results (left: first 15 seconds; right: last 15 seconds):", 
            "title": "Experiment: Helicopter"
        }, 
        {
            "location": "/exp_heli/#helicopter", 
            "text": "Example  Helicopter/    Where you can find this helicopter  Quanser website.  3 DoF Helicopter .  \nModel:\nBenchmark model of Quanser\u2019s 3 DOF Helicopter - 2018", 
            "title": "Helicopter"
        }, 
        {
            "location": "/exp_heli/#problem-description", 
            "text": "The state vector of the helicopter is  x =  [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} x =  [q,\\dot{q} ]^{T}\\in\\mathbb{R}^{6} , where  q = [\\epsilon,\\rho,\\lambda]^T q = [\\epsilon,\\rho,\\lambda]^T  is the vector of the elevation angle, pitch angle, and yaw angle. The pitch angle  \\rho \\rho  is set to be  |\\rho|\\leq 1 |\\rho|\\leq 1 .    The input vector is  u=[V_f,V_b]^T u=[V_f,V_b]^T , where  V_f V_f  is the voltage on the front motor and   V_b V_b  is the voltage on the back motor. The control input is bounded by  [0,0]^T \\leq u \\leq [20,20]^T [0,0]^T \\leq u \\leq [20,20]^T .    The dynamics of the helicopter are given by the following equations:     \\begin{align*}\n\\ddot{q}\n = -\\left[\n\\begin{array}{c}\n\\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ \n-a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ \n0\n\\end{array} \n\\right]\n-\n\\left[\n\\begin{array}{ccc}\nC_\\epsilon       \\\\    C_\\rho   \\\\      C_\\lambda\n\\end{array} \n\\right]\\dot{q}\\\\ +K_f\n\\left[\n\\begin{array}{cc}\nb_{\\epsilon}\\cos(\\rho)  0 \\\\ \n0    b_{\\rho}\\\\ \nb_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)  0\n\\end{array} \n\\right]u\n\\end{align*}  \\begin{align*}\n\\ddot{q}\n =\n&-\\left[\n\\begin{array}{c}\n\\sin(\\epsilon)(a_{\\epsilon_1}+a_{\\epsilon_2}\\cos(\\rho)) \\\\ \n-a_{\\rho} \\cos(\\epsilon)\\sin(\\rho)\\\\ \n0\n\\end{array} \n\\right]\n-\n\\left[\n\\begin{array}{ccc}\nC_\\epsilon &  &  \\\\ \n&  C_\\rho&  \\\\ \n&  & C_\\lambda\n\\end{array} \n\\right]\\dot{q}\\\\\n&+K_f\n\\left[\n\\begin{array}{cc}\nb_{\\epsilon}\\cos(\\rho)& 0 \\\\ \n0 &  b_{\\rho}\\\\ \nb_{\\lambda}\\cos(\\epsilon)\\sin(\\rho)& 0\n\\end{array} \n\\right]u\n\\end{align*}   The task is to control the helicopter to track a given yaw reference.", 
            "title": "Problem Description"
        }, 
        {
            "location": "/exp_heli/#ocp-in-parnmpc", 
            "text": "The state constraints are softened by introducing a slack variable  \\rho_s \\rho_s .  The underlying OCP defined in  ParNMPC  is formulated as:   State:  x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T x=[\\epsilon,\\rho,\\lambda,\\dot\\epsilon,\\dot\\rho,\\dot\\lambda]^T .  Input:  u=[V_f,V_b,\\rho_s]^T u=[V_f,V_b,\\rho_s]^T  with  u_{max}=[20,20,\\infty]^T u_{max}=[20,20,\\infty]^T  and  u_{min} = [0,0,0]^T u_{min} = [0,0,0]^T .  Parameter:  p=[Q_d,R_d,x_{ref},\\gamma]^T p=[Q_d,R_d,x_{ref},\\gamma]^T , where  Q_d Q_d  and  R_d R_d  are tuning parameters,  x_{ref} x_{ref}  is the varying reference, and  \\gamma 0 \\gamma>0  is the barrier parameter.  Cost function  L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) L(u,x,p) = L_{tracking}(u,x,p) + L_{penalty}(u,x,p) , where  L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2 L_{tracking}(u,x,p) = \\frac{1}{2}\\|x-x_{ref}\\|_{Q_d}^2+\\frac{1}{2}\\|u-u_{ref}\\|_{R_d}^2  and  L_{penalty}(u,x,p)=1000\\rho_s^2 L_{penalty}(u,x,p)=1000\\rho_s^2  is the penalty function.  Polytopic function (linear constraint):  G = [\\rho - \\rho_s, \\rho + \\rho_s]^T G = [\\rho - \\rho_s, \\rho + \\rho_s]^T  with  G_{max}=[1,\\infty]^T G_{max}=[1,\\infty]^T  and  G_{min} = [-\\infty,-1]^T G_{min} = [-\\infty,-1]^T .  f(u,x,p) f(u,x,p)  is shown before.  Prediction horizon  T=4 T=4  s.  Number of the discritization grids  N=48 N=48 .  Discretization method: Euler.   Experiment settings:   CPU: i7-8700K.  MATLAB R2015b + Microsoft Visual C++ 2015 (C)  Tolerance: 1e-4.  DoP: 4.  Hessian approximation method: Newton.", 
            "title": "OCP in ParNMPC"
        }, 
        {
            "location": "/exp_heli/#closed-loop-control-using-parnmpc", 
            "text": "", 
            "title": "Closed-loop control using ParNMPC"
        }, 
        {
            "location": "/exp_heli/#step-1-nmpc-problem-formulation", 
            "text": "See  Workflow of ParNMPC   NMPC Problem Formulation .   Example  Helicopter/NMPC_Problem_Formulation.m", 
            "title": "Step 1. NMPC problem formulation"
        }, 
        {
            "location": "/exp_heli/#step-2-code-generation-and-deployment-in-simulink", 
            "text": "See  Workflow of ParNMPC   Code Generation and Deployment   Simulink .    Code generation   Example  Helicopter/Simulink_Setup.m     Deployment   Example  Helicopter/Deploy_Simulink_R2015b.slx   Add  -openmp  to the makefile provided by Quanser.    Experiment results (left: first 15 seconds; right: last 15 seconds):", 
            "title": "Step 2. Code generation and deployment in Simulink"
        }, 
        {
            "location": "/tips/", 
            "text": "Tips\n\n\nSolving the Very First OCP\n\n\nIn most of the cases, the very first OCP can be solved offline so that warm-start can be used.\nIn solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. \nThen, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before.\n\n\nDegree of Parallelism (DoP)\n\n\nDoP\n is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller \nDoP\n. In the case of \nDoP=1\n, the solver is exactly equivalent to the interior-point method.\n\n\nMeanwhile, when you want to generate serial code without any parallel computing, you can set \nDoP\n to 1 and edit \nTimer.m\n to specify your own timer function (the default is \nomp_get_wtime\n, which is not supported when OpenMP is disabled).\n\n\nTuning\n\n\n\n\nSpecify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.", 
            "title": "Tips"
        }, 
        {
            "location": "/tips/#tips", 
            "text": "", 
            "title": "Tips"
        }, 
        {
            "location": "/tips/#solving-the-very-first-ocp", 
            "text": "In most of the cases, the very first OCP can be solved offline so that warm-start can be used.\nIn solving the very first OCP offline, you can start with an easy-to-solve OCP, for example, OCP with less constraints or mild parameters. \nThen, you can gradually modify and solve the OCP to the one you want by starting from the solution obtained before.", 
            "title": "Solving the Very First OCP"
        }, 
        {
            "location": "/tips/#degree-of-parallelism-dop", 
            "text": "DoP  is a parameter to specify the number of pieces to split the OCP along the prediction horizon for parallel computing. In general, a faster rate of convergence can be achieved by choosing a smaller  DoP . In the case of  DoP=1 , the solver is exactly equivalent to the interior-point method.  Meanwhile, when you want to generate serial code without any parallel computing, you can set  DoP  to 1 and edit  Timer.m  to specify your own timer function (the default is  omp_get_wtime , which is not supported when OpenMP is disabled).", 
            "title": "Degree of Parallelism (DoP)"
        }, 
        {
            "location": "/tips/#tuning", 
            "text": "Specify the tuning parameters such as the weighting matrices as parameters so that they can be tuned without re-generating the OCP.", 
            "title": "Tuning"
        }, 
        {
            "location": "/about/", 
            "text": "About\n\n\nParNMPC\n is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.\n\n\nCiting ParNMPC\n\n\nComing soon.\n\n\nContacting Us\n\n\nPlease do not hesitate to contact us if you have any questions.\nWe would be very happy to hear your advices, experiences, stories, and contributions.\n\n\nYou can contact us by:\n\n\n\n\nposting an issue on \nParNMPC: Issue\n.\n\n\nE-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp\n\n\njoining our QQ Group: 339029295\n\n\n\n\nLicense\n\n\nParNMPC is distributed under the GNU Lesser General Public License v3.0.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about", 
            "text": "ParNMPC  is developed by Haoyang Deng under the supervision of Prof. Toshiyuki Ohtsuka.", 
            "title": "About"
        }, 
        {
            "location": "/about/#citing-parnmpc", 
            "text": "Coming soon.", 
            "title": "Citing ParNMPC"
        }, 
        {
            "location": "/about/#contacting-us", 
            "text": "Please do not hesitate to contact us if you have any questions.\nWe would be very happy to hear your advices, experiences, stories, and contributions.  You can contact us by:   posting an issue on  ParNMPC: Issue .  E-mail: deng.haoyang.23r [at] st.kyoto-u.ac.jp  joining our QQ Group: 339029295", 
            "title": "Contacting Us"
        }, 
        {
            "location": "/about/#license", 
            "text": "ParNMPC is distributed under the GNU Lesser General Public License v3.0.", 
            "title": "License"
        }
    ]
}